/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export const enum Level {
  Debug = 3,
  Error = 0,
  Info = 2,
  Trace = 4,
  Warn = 1,
  Off = 5
}
export const MAX_REQUEST_ARGS_LEN: number
export const DEFAULT_REQUEST_TIMEOUT_IN_MILLISECONDS: number
export const DEFAULT_CONNECTION_TIMEOUT_IN_MILLISECONDS: number
export const DEFAULT_INFLIGHT_REQUESTS_LIMIT: number
/**
 * Configuration for OpenTelemetry integration in the Node.js client.
 *
 * This struct allows you to configure how telemetry data (traces and metrics) is exported to an OpenTelemetry collector.
 * - `traces`: Optional configuration for exporting trace data. If `None`, trace data will not be exported.
 * - `metrics`: Optional configuration for exporting metrics data. If `None`, metrics data will not be exported.
 * - `flush_interval_ms`: Optional interval in milliseconds between consecutive exports of telemetry data. If `None`, a default value will be used.
 *
 * At least one of traces or metrics must be provided.
 */
export interface OpenTelemetryConfig {
  /** Optional configuration for exporting trace data. If `None`, trace data will not be exported. */
  traces?: OpenTelemetryTracesConfig
  /** Optional configuration for exporting metrics data. If `None`, metrics data will not be exported. */
  metrics?: OpenTelemetryMetricsConfig
  /** Optional interval in milliseconds between consecutive exports of telemetry data. If `None`, the default `DEFAULT_FLUSH_SIGNAL_INTERVAL_MS` will be used. */
  flushIntervalMs?: number
}
/**
 * Configuration for exporting OpenTelemetry traces.
 *
 * - `endpoint`: The endpoint to which trace data will be exported. Expected format:
 *   - For gRPC: `grpc://host:port`
 *   - For HTTP: `http://host:port` or `https://host:port`
 *   - For file exporter: `file:///absolute/path/to/folder/file.json`
 * - `sample_percentage`: The percentage of requests to sample and create a span for, used to measure command duration. If `None`, a default value DEFAULT_TRACE_SAMPLE_PERCENTAGE will be used.
 *   Note: There is a tradeoff between sampling percentage and performance. Higher sampling percentages will provide more detailed telemetry data but will impact performance.
 *   It is recommended to keep this number low (1-5%) in production environments unless you have specific needs for higher sampling rates.
 */
export interface OpenTelemetryTracesConfig {
  /** The endpoint to which trace data will be exported. */
  endpoint: string
  /**
   * The percentage of requests to sample and create a span for, used to measure command duration. If `None`, a default value DEFAULT_TRACE_SAMPLE_PERCENTAGE will be used.
   * Note: There is a tradeoff between sampling percentage and performance. Higher sampling percentages will provide more detailed telemetry data but will impact performance.
   * It is recommended to keep this number low (1-5%) in production environments unless you have specific needs for higher sampling rates.
   */
  samplePercentage?: number
}
/**
 * Configuration for exporting OpenTelemetry metrics.
 *
 * - `endpoint`: The endpoint to which metrics data will be exported. Expected format:
 *   - For gRPC: `grpc://host:port`
 *   - For HTTP: `http://host:port` or `https://host:port`
 *   - For file exporter: `file:///absolute/path/to/folder/file.json`
 */
export interface OpenTelemetryMetricsConfig {
  /** The endpoint to which metrics data will be exported. */
  endpoint: string
}
export declare function StartSocketConnection(): Promise<string>
export declare function InitOpenTelemetry(openTelemetryConfig: OpenTelemetryConfig): void
export declare function log(logLevel: Level, logIdentifier: string, message: string): void
export declare function InitInternalLogger(level?: Level | undefined | null, fileName?: string | undefined | null): Level
export declare function valueFromSplitPointer(highBits: number, lowBits: number, stringDecoder: boolean): null | string | Uint8Array | number | {} | Boolean | BigInt | Set<any> | any[] | Buffer
/**
 * @internal @test
 * This function is for tests that require a value allocated on the heap.
 * Should NOT be used in production.
 */
export declare function createLeakedStringVec(message: Array<Uint8Array>): [number, number]
/** Creates an open telemetry span with the given name and returns a pointer to the span */
export declare function createLeakedOtelSpan(name: string): [number, number]
export declare function dropOtelSpan(spanPtr: bigint): void
export declare function getStatistics(): object
export declare class AsyncClient {
  static CreateConnection(connectionAddress: string): AsyncClient
  get(key: string): Promise<string | Buffer | null>
  set(key: string, value: string): Promise<string | Buffer | "OK" | null>
}
/**
 * A wrapper for a script object. As long as this object is alive, the script's code is saved in memory, and can be resent to the server.
 *
 * **IMPORTANT**: Script objects are NOT automatically garbage collected. You are responsible for calling `release()`
 * on every Script object when you're done with it to prevent memory leaks. Failure to do so will result in memory leaks.
 */
export declare class Script {
  /** Construct with the script's code. */
  constructor(code: string | Uint8Array)
  /** Returns the hash of the script. */
  getHash(): string
  /**
   * Decrements the script's reference count in the local container.
   * Removes the script when the count reaches zero.
   *
   * You need to call this method when you're done with the Script object. Script objects are NOT
   * automatically garbage collected, and failure to call release() will result in memory leaks.
   */
  release(): void
}
/**
 * This struct is used to keep track of the cursor of a cluster scan.
 * We want to avoid passing the cursor between layers of the application,
 * So we keep the state in the container and only pass the id of the cursor.
 * The cursor is stored in the container and can be retrieved using the id.
 * The cursor is removed from the container when the object is deleted (dropped).
 * To create a cursor:
 * ```typescript
 * // For a new cursor
 * let cursor = new ClusterScanCursor();
 * // Using an existing id
 * let cursor = new ClusterScanCursor("cursor_id");
 * ```
 * To get the cursor id:
 * ```typescript
 * let cursorId = cursor.getCursor();
 * ```
 * To check if the scan is finished:
 * ```typescript
 * let isFinished = cursor.isFinished(); // true if the scan is finished
 * ```
 */
export declare class ClusterScanCursor {
  constructor(newCursor?: string | undefined | null)
  /** Returns the cursor id. */
  getCursor(): string
  /** Returns true if the scan is finished. */
  isFinished(): boolean
}
