"use strict";
/**
 * Copyright Valkey GLIDE Project Contributors - SPDX Identifier: Apache-2.0
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimeUnit = exports.ScoreFilter = exports.SortOrder = exports.GeoUnit = exports.HashExpirationCondition = exports.HashFieldConditionalChange = exports.ConditionalChange = exports.FlushMode = exports.BitmapIndexType = exports.FunctionRestorePolicy = exports.InsertPosition = exports.InfBoundary = exports.UpdateByScore = exports.ExpireOptions = exports.ListDirection = exports.BitFieldOverflow = exports.BitOverflowControl = exports.BitFieldIncrBy = exports.BitFieldSet = exports.BitFieldGet = exports.BitOffsetMultiplier = exports.BitOffset = exports.UnsignedEncoding = exports.SignedEncoding = exports.BitwiseOperation = exports.InfoOptions = void 0;
exports.parseInfoResponse = parseInfoResponse;
exports.createGet = createGet;
exports.createGetDel = createGetDel;
exports.createGetRange = createGetRange;
exports.createSet = createSet;
exports.createPing = createPing;
exports.createInfo = createInfo;
exports.createDel = createDel;
exports.createSelect = createSelect;
exports.createClientGetName = createClientGetName;
exports.createConfigRewrite = createConfigRewrite;
exports.createConfigResetStat = createConfigResetStat;
exports.createMGet = createMGet;
exports.createMSet = createMSet;
exports.createMSetNX = createMSetNX;
exports.createIncr = createIncr;
exports.createIncrBy = createIncrBy;
exports.createIncrByFloat = createIncrByFloat;
exports.createClientId = createClientId;
exports.createConfigGet = createConfigGet;
exports.createConfigSet = createConfigSet;
exports.createHGet = createHGet;
exports.convertFieldsAndValuesToHashDataType = convertFieldsAndValuesToHashDataType;
exports.createHSet = createHSet;
exports.createHKeys = createHKeys;
exports.createHSetNX = createHSetNX;
exports.createHSetEx = createHSetEx;
exports.createHGetEx = createHGetEx;
exports.createHExpire = createHExpire;
exports.createHPersist = createHPersist;
exports.createHPExpire = createHPExpire;
exports.createHExpireAt = createHExpireAt;
exports.createHPExpireAt = createHPExpireAt;
exports.createHTtl = createHTtl;
exports.createHPTtl = createHPTtl;
exports.createHExpireTime = createHExpireTime;
exports.createHPExpireTime = createHPExpireTime;
exports.createDecr = createDecr;
exports.createDecrBy = createDecrBy;
exports.createBitOp = createBitOp;
exports.createGetBit = createGetBit;
exports.createSetBit = createSetBit;
exports.createBitField = createBitField;
exports.createHDel = createHDel;
exports.createHMGet = createHMGet;
exports.createHExists = createHExists;
exports.createHGetAll = createHGetAll;
exports.createLPush = createLPush;
exports.createLPushX = createLPushX;
exports.createLPop = createLPop;
exports.createLRange = createLRange;
exports.createLLen = createLLen;
exports.createLMove = createLMove;
exports.createBLMove = createBLMove;
exports.createLSet = createLSet;
exports.createLTrim = createLTrim;
exports.createLRem = createLRem;
exports.createRPush = createRPush;
exports.createRPushX = createRPushX;
exports.createRPop = createRPop;
exports.createSAdd = createSAdd;
exports.createSRem = createSRem;
exports.createSScan = createSScan;
exports.createSMembers = createSMembers;
exports.createSMove = createSMove;
exports.createSCard = createSCard;
exports.createSInter = createSInter;
exports.createSInterCard = createSInterCard;
exports.createSInterStore = createSInterStore;
exports.createSDiff = createSDiff;
exports.createSDiffStore = createSDiffStore;
exports.createSUnion = createSUnion;
exports.createSUnionStore = createSUnionStore;
exports.createSIsMember = createSIsMember;
exports.createSMIsMember = createSMIsMember;
exports.createSPop = createSPop;
exports.createSRandMember = createSRandMember;
exports.createCustomCommand = createCustomCommand;
exports.createHIncrBy = createHIncrBy;
exports.createHIncrByFloat = createHIncrByFloat;
exports.createHLen = createHLen;
exports.createHVals = createHVals;
exports.createExists = createExists;
exports.createUnlink = createUnlink;
exports.createExpire = createExpire;
exports.createExpireAt = createExpireAt;
exports.createExpireTime = createExpireTime;
exports.createPExpire = createPExpire;
exports.createPExpireAt = createPExpireAt;
exports.createPExpireTime = createPExpireTime;
exports.createTTL = createTTL;
exports.convertElementsAndScores = convertElementsAndScores;
exports.createZAdd = createZAdd;
exports.createZInterstore = createZInterstore;
exports.createZInter = createZInter;
exports.createZUnion = createZUnion;
exports.createZRem = createZRem;
exports.createZCard = createZCard;
exports.createZInterCard = createZInterCard;
exports.createZDiff = createZDiff;
exports.createZDiffWithScores = createZDiffWithScores;
exports.createZDiffStore = createZDiffStore;
exports.createZScore = createZScore;
exports.createZUnionStore = createZUnionStore;
exports.createZMScore = createZMScore;
exports.createScan = createScan;
exports.createZCount = createZCount;
exports.createZRange = createZRange;
exports.createZRangeWithScores = createZRangeWithScores;
exports.createZRangeStore = createZRangeStore;
exports.createType = createType;
exports.createStrlen = createStrlen;
exports.createLIndex = createLIndex;
exports.createLInsert = createLInsert;
exports.createZPopMin = createZPopMin;
exports.createZPopMax = createZPopMax;
exports.createEcho = createEcho;
exports.createPTTL = createPTTL;
exports.createZRemRangeByRank = createZRemRangeByRank;
exports.createZRemRangeByLex = createZRemRangeByLex;
exports.createZRemRangeByScore = createZRemRangeByScore;
exports.createPersist = createPersist;
exports.createZLexCount = createZLexCount;
exports.createZRank = createZRank;
exports.createXAdd = createXAdd;
exports.createXDel = createXDel;
exports.createXTrim = createXTrim;
exports.createXRange = createXRange;
exports.createXRevRange = createXRevRange;
exports.createXGroupCreateConsumer = createXGroupCreateConsumer;
exports.createXGroupDelConsumer = createXGroupDelConsumer;
exports.createTime = createTime;
exports.createPublish = createPublish;
exports.createBRPop = createBRPop;
exports.createBLPop = createBLPop;
exports.createFCall = createFCall;
exports.createFCallReadOnly = createFCallReadOnly;
exports.createFunctionDelete = createFunctionDelete;
exports.createFunctionFlush = createFunctionFlush;
exports.createFunctionLoad = createFunctionLoad;
exports.createFunctionList = createFunctionList;
exports.createFunctionStats = createFunctionStats;
exports.createFunctionKill = createFunctionKill;
exports.createFunctionDump = createFunctionDump;
exports.createFunctionRestore = createFunctionRestore;
exports.createBitCount = createBitCount;
exports.createBitPos = createBitPos;
exports.convertKeysAndEntries = convertKeysAndEntries;
exports.createXRead = createXRead;
exports.createXReadGroup = createXReadGroup;
exports.createXInfoStream = createXInfoStream;
exports.createXInfoGroups = createXInfoGroups;
exports.createXLen = createXLen;
exports.createXPending = createXPending;
exports.createXInfoConsumers = createXInfoConsumers;
exports.createXClaim = createXClaim;
exports.createXAutoClaim = createXAutoClaim;
exports.createXGroupCreate = createXGroupCreate;
exports.createXGroupDestroy = createXGroupDestroy;
exports.createRename = createRename;
exports.createRenameNX = createRenameNX;
exports.createPfAdd = createPfAdd;
exports.createPfCount = createPfCount;
exports.createPfMerge = createPfMerge;
exports.createObjectEncoding = createObjectEncoding;
exports.createObjectFreq = createObjectFreq;
exports.createObjectIdletime = createObjectIdletime;
exports.createObjectRefcount = createObjectRefcount;
exports.createLolwut = createLolwut;
exports.createFlushAll = createFlushAll;
exports.createFlushDB = createFlushDB;
exports.createCopy = createCopy;
exports.createMove = createMove;
exports.createDump = createDump;
exports.createRestore = createRestore;
exports.createLPos = createLPos;
exports.createDBSize = createDBSize;
exports.createGeoAdd = createGeoAdd;
exports.createGeoPos = createGeoPos;
exports.createGeoDist = createGeoDist;
exports.createGeoHash = createGeoHash;
exports.createGeoSearch = createGeoSearch;
exports.createGeoSearchStore = createGeoSearchStore;
exports.createZRevRank = createZRevRank;
exports.createZRevRankWithScore = createZRevRankWithScore;
exports.createZMPop = createZMPop;
exports.createBZMPop = createBZMPop;
exports.createZIncrBy = createZIncrBy;
exports.createSort = createSort;
exports.createSortReadOnly = createSortReadOnly;
exports.createHStrlen = createHStrlen;
exports.createHRandField = createHRandField;
exports.createHScan = createHScan;
exports.createZRandMember = createZRandMember;
exports.createLastSave = createLastSave;
exports.createLCS = createLCS;
exports.createTouch = createTouch;
exports.createRandomKey = createRandomKey;
exports.createWatch = createWatch;
exports.createUnWatch = createUnWatch;
exports.createWait = createWait;
exports.createZScan = createZScan;
exports.createSetRange = createSetRange;
exports.createAppend = createAppend;
exports.createLMPop = createLMPop;
exports.createBLMPop = createBLMPop;
exports.createPubSubChannels = createPubSubChannels;
exports.createPubSubNumPat = createPubSubNumPat;
exports.createPubSubNumSub = createPubSubNumSub;
exports.createPubsubShardChannels = createPubsubShardChannels;
exports.createPubSubShardNumSub = createPubSubShardNumSub;
exports.createBZPopMax = createBZPopMax;
exports.createBZPopMin = createBZPopMin;
exports.createScriptShow = createScriptShow;
exports.createGetEx = createGetEx;
exports.createXAck = createXAck;
exports.createXGroupSetid = createXGroupSetid;
exports.createScriptExists = createScriptExists;
exports.createScriptFlush = createScriptFlush;
exports.createScriptKill = createScriptKill;
/**
 * Note: 'eslint-disable-line @typescript-eslint/no-unused-vars' is used intentionally
 * to suppress unused import errors for types referenced only in JSDoc.
 */
const long_1 = __importDefault(require("long"));
const BaseClient_1 = require("./BaseClient");
const native_1 = require("../build-ts/native");
const ProtobufMessage_1 = require("../build-ts/ProtobufMessage");
var RequestType = ProtobufMessage_1.command_request.RequestType;
function isLargeCommand(args) {
    let lenSum = 0;
    for (const arg of args) {
        lenSum += arg.length;
        if (lenSum >= native_1.MAX_REQUEST_ARGS_LEN) {
            return true;
        }
    }
    return false;
}
/**
 * Convert a string array into Uint8Array[]
 */
function toBuffersArray(args) {
    const argsBytes = [];
    for (const arg of args) {
        if (typeof arg == "string") {
            argsBytes.push(Buffer.from(arg));
        }
        else {
            argsBytes.push(arg);
        }
    }
    return argsBytes;
}
/**
 * @test
 */
function parseInfoResponse(response) {
    const lines = response.split("\n");
    const parsedResponse = {};
    for (const line of lines) {
        // Ignore lines that start with '#'
        if (!line.startsWith("#")) {
            const [key, value] = line.trim().split(":");
            parsedResponse[key] = value;
        }
    }
    return parsedResponse;
}
function createCommand(requestType, args) {
    const singleCommand = ProtobufMessage_1.command_request.Command.create({
        requestType,
    });
    const argsBytes = toBuffersArray(args);
    if (isLargeCommand(args)) {
        // pass as a pointer
        const pointerArr = (0, native_1.createLeakedStringVec)(argsBytes);
        const pointer = new long_1.default(pointerArr[0], pointerArr[1]);
        singleCommand.argsVecPointer = pointer;
    }
    else {
        singleCommand.argsArray = ProtobufMessage_1.command_request.Command.ArgsArray.create({
            args: argsBytes,
        });
    }
    return singleCommand;
}
/**
 * @internal
 */
function createGet(key) {
    return createCommand(RequestType.Get, [key]);
}
/**
 * @internal
 */
function createGetDel(key) {
    return createCommand(RequestType.GetDel, [key]);
}
/**
 * @internal
 */
function createGetRange(key, start, end) {
    return createCommand(RequestType.GetRange, [
        key,
        start.toString(),
        end.toString(),
    ]);
}
/**
 * @internal
 */
function createSet(key, value, options) {
    const args = [key, value];
    if (options) {
        if (options.conditionalSet === "onlyIfExists") {
            args.push("XX");
        }
        else if (options.conditionalSet === "onlyIfDoesNotExist") {
            args.push("NX");
        }
        else if (options.conditionalSet === "onlyIfEqual") {
            args.push("IFEQ", options.comparisonValue);
        }
        if (options.returnOldValue) {
            args.push("GET");
        }
        if (options.expiry) {
            if (options.expiry !== "keepExisting" &&
                !Number.isInteger(options.expiry.count)) {
                throw new Error(`Received expiry '${JSON.stringify(options.expiry)}'. Count must be an integer`);
            }
            if (options.expiry === "keepExisting") {
                args.push("KEEPTTL");
            }
            else {
                args.push(options.expiry.type, options.expiry.count.toString());
            }
        }
    }
    return createCommand(RequestType.Set, args);
}
/**
 * INFO option: a specific section of information:
 * When no parameter is provided, the default option is assumed.
 */
var InfoOptions;
(function (InfoOptions) {
    /**
     * SERVER: General information about the server
     */
    InfoOptions["Server"] = "server";
    /**
     * CLIENTS: Client connections section
     */
    InfoOptions["Clients"] = "clients";
    /**
     * MEMORY: Memory consumption related information
     */
    InfoOptions["Memory"] = "memory";
    /**
     * PERSISTENCE: RDB and AOF related information
     */
    InfoOptions["Persistence"] = "persistence";
    /**
     * STATS: General statistics
     */
    InfoOptions["Stats"] = "stats";
    /**
     * REPLICATION: Master/replica replication information
     */
    InfoOptions["Replication"] = "replication";
    /**
     * CPU: CPU consumption statistics
     */
    InfoOptions["Cpu"] = "cpu";
    /**
     * COMMANDSTATS: Valkey command statistics
     */
    InfoOptions["Commandstats"] = "commandstats";
    /**
     * LATENCYSTATS: Valkey command latency percentile distribution statistics
     */
    InfoOptions["Latencystats"] = "latencystats";
    /**
     * SENTINEL: Valkey Sentinel section (only applicable to Sentinel instances)
     */
    InfoOptions["Sentinel"] = "sentinel";
    /**
     * CLUSTER: Valkey Cluster section
     */
    InfoOptions["Cluster"] = "cluster";
    /**
     * MODULES: Modules section
     */
    InfoOptions["Modules"] = "modules";
    /**
     * KEYSPACE: Database related statistics
     */
    InfoOptions["Keyspace"] = "keyspace";
    /**
     * ERRORSTATS: Valkey error statistics
     */
    InfoOptions["Errorstats"] = "errorstats";
    /**
     * ALL: Return all sections (excluding module generated ones)
     */
    InfoOptions["All"] = "all";
    /**
     * DEFAULT: Return only the default set of sections
     */
    InfoOptions["Default"] = "default";
    /**
     * EVERYTHING: Includes all and modules
     */
    InfoOptions["Everything"] = "everything";
})(InfoOptions || (exports.InfoOptions = InfoOptions = {}));
/**
 * @internal
 */
function createPing(str) {
    const args = str == undefined ? [] : [str];
    return createCommand(RequestType.Ping, args);
}
/**
 * @internal
 */
function createInfo(options) {
    const args = options == undefined ? [] : options;
    return createCommand(RequestType.Info, args);
}
/**
 * @internal
 */
function createDel(keys) {
    return createCommand(RequestType.Del, keys);
}
/**
 * @internal
 */
function createSelect(index) {
    return createCommand(RequestType.Select, [index.toString()]);
}
/**
 * @internal
 */
function createClientGetName() {
    return createCommand(RequestType.ClientGetName, []);
}
/**
 * @internal
 */
function createConfigRewrite() {
    return createCommand(RequestType.ConfigRewrite, []);
}
/**
 * @internal
 */
function createConfigResetStat() {
    return createCommand(RequestType.ConfigResetStat, []);
}
/**
 * @internal
 */
function createMGet(keys) {
    return createCommand(RequestType.MGet, keys);
}
/**
 * @internal
 */
function createMSet(keysAndValues) {
    return createCommand(RequestType.MSet, keysAndValues.flatMap((e) => [e.key, e.value]));
}
/**
 * @internal
 */
function createMSetNX(keysAndValues) {
    return createCommand(RequestType.MSetNX, keysAndValues.flatMap((e) => [e.key, e.value]));
}
/**
 * @internal
 */
function createIncr(key) {
    return createCommand(RequestType.Incr, [key]);
}
/**
 * @internal
 */
function createIncrBy(key, amount) {
    return createCommand(RequestType.IncrBy, [key, amount.toString()]);
}
/**
 * @internal
 */
function createIncrByFloat(key, amount) {
    return createCommand(RequestType.IncrByFloat, [key, amount.toString()]);
}
/**
 * @internal
 */
function createClientId() {
    return createCommand(RequestType.ClientId, []);
}
/**
 * @internal
 */
function createConfigGet(parameters) {
    return createCommand(RequestType.ConfigGet, parameters);
}
/**
 * @internal
 */
function createConfigSet(parameters) {
    return createCommand(RequestType.ConfigSet, Object.entries(parameters).flat());
}
/**
 * @internal
 */
function createHGet(key, field) {
    return createCommand(RequestType.HGet, [key, field]);
}
/**
 * This function converts an input from {@link HashDataType} or `Record` types to `HashDataType`.
 *
 * @param fieldsAndValues - field names and their values.
 * @returns HashDataType array containing field names and their values.
 */
function convertFieldsAndValuesToHashDataType(fieldsAndValues) {
    if (!Array.isArray(fieldsAndValues)) {
        return Object.entries(fieldsAndValues).map(([field, value]) => {
            return { field, value };
        });
    }
    return fieldsAndValues;
}
/**
 * @internal
 */
function createHSet(key, fieldValueList) {
    return createCommand(RequestType.HSet, [key].concat(fieldValueList
        .map((fieldValueObject) => [
        fieldValueObject.field,
        fieldValueObject.value,
    ])
        .flat()));
}
/**
 * @internal
 */
function createHKeys(key) {
    return createCommand(RequestType.HKeys, [key]);
}
/**
 * @internal
 */
function createHSetNX(key, field, value) {
    return createCommand(RequestType.HSetNX, [key, field, value]);
}
/**
 * @internal
 */
function createHSetEx(key, fieldValueMap, options) {
    const args = [key];
    // Add field conditional change options (FNX | FXX)
    if (options?.fieldConditionalChange) {
        args.push(options.fieldConditionalChange);
    }
    // Add expiry options (EX | PX | EXAT | PXAT | KEEPTTL)
    // Note: PERSIST is not supported by HSETEX
    if (options?.expiry) {
        if (options.expiry === "KEEPTTL") {
            args.push("KEEPTTL");
        }
        else {
            // Validate that count is an integer
            if (!Number.isInteger(options.expiry.count)) {
                throw new Error(`HSETEX received expiry '${JSON.stringify(options.expiry)}'. Count must be an integer`);
            }
            args.push(options.expiry.type, options.expiry.count.toString());
        }
    }
    // Only add FIELDS keyword and field count if fieldValueMap is not empty
    if (fieldValueMap.length > 0) {
        args.push("FIELDS", fieldValueMap.length.toString());
        // Add field-value pairs
        fieldValueMap.forEach((fieldValueObject) => {
            args.push(fieldValueObject.field, fieldValueObject.value);
        });
    }
    return createCommand(RequestType.HSetEx, args);
}
/**
 * @internal
 */
function createHGetEx(key, fields, options) {
    const args = [key];
    // Add expiry options (EX | PX | EXAT | PXAT | PERSIST)
    // Note: HGETEX does not support KEEPTTL
    if (options?.expiry) {
        if (options.expiry === "PERSIST") {
            args.push("PERSIST");
        }
        else {
            // Validate that count is an integer
            if (!Number.isInteger(options.expiry.count)) {
                throw new Error(`HGETEX received expiry '${JSON.stringify(options.expiry)}'. Count must be an integer`);
            }
            args.push(options.expiry.type, options.expiry.count.toString());
        }
    }
    // Add FIELDS keyword and field count - always required when fields parameter exists
    args.push("FIELDS", fields.length.toString());
    // Add field names
    args.push(...fields);
    return createCommand(RequestType.HGetEx, args);
}
/**
 * @internal
 */
function createHExpire(key, seconds, fields, options) {
    const args = [key, seconds.toString()];
    // Add condition options (NX | XX | GT | LT)
    if (options?.condition) {
        args.push(options.condition);
    }
    // Add FIELDS keyword and field count - always required when fields parameter exists
    args.push("FIELDS", fields.length.toString());
    // Add field names
    args.push(...fields);
    return createCommand(RequestType.HExpire, args);
}
/**
 * @internal
 */
function createHPersist(key, fields) {
    const args = [key];
    // Add FIELDS keyword and field count - always required when fields parameter exists
    args.push("FIELDS", fields.length.toString());
    // Add field names
    args.push(...fields);
    return createCommand(RequestType.HPersist, args);
}
/**
 * @internal
 */
function createHPExpire(key, milliseconds, fields, options) {
    const args = [key, milliseconds.toString()];
    // Add condition options (NX | XX | GT | LT)
    if (options?.condition) {
        args.push(options.condition);
    }
    // Add FIELDS keyword and field count - always required when fields parameter exists
    args.push("FIELDS", fields.length.toString());
    // Add field names
    args.push(...fields);
    return createCommand(RequestType.HPExpire, args);
}
/**
 * @internal
 */
function createHExpireAt(key, unixTimestampSeconds, fields, options) {
    const args = [key, unixTimestampSeconds.toString()];
    // Add condition options (NX | XX | GT | LT)
    if (options?.condition) {
        args.push(options.condition);
    }
    // Add FIELDS keyword and field count - always required when fields parameter exists
    args.push("FIELDS", fields.length.toString());
    // Add field names
    args.push(...fields);
    return createCommand(RequestType.HExpireAt, args);
}
/**
 * @internal
 */
function createHPExpireAt(key, unixTimestampMilliseconds, fields, options) {
    const args = [key, unixTimestampMilliseconds.toString()];
    // Add condition options (NX | XX | GT | LT)
    if (options?.condition) {
        args.push(options.condition);
    }
    // Add FIELDS keyword and field count - always required when fields parameter exists
    args.push("FIELDS", fields.length.toString());
    // Add field names
    args.push(...fields);
    return createCommand(RequestType.HPExpireAt, args);
}
/**
 * @internal
 */
function createHTtl(key, fields) {
    const args = [key];
    // Add FIELDS keyword and field count - always required when fields parameter exists
    args.push("FIELDS", fields.length.toString());
    // Add field names
    args.push(...fields);
    return createCommand(RequestType.HTtl, args);
}
/**
 * @internal
 */
function createHPTtl(key, fields) {
    const args = [key];
    // Add FIELDS keyword and field count - always required when fields parameter exists
    args.push("FIELDS", fields.length.toString());
    // Add field names
    args.push(...fields);
    return createCommand(RequestType.HPTtl, args);
}
/**
 * @internal
 */
function createHExpireTime(key, fields) {
    const args = [key];
    // Add FIELDS keyword and field count - always required when fields parameter exists
    args.push("FIELDS", fields.length.toString());
    // Add field names
    args.push(...fields);
    return createCommand(RequestType.HExpireTime, args);
}
/**
 * @internal
 */
function createHPExpireTime(key, fields) {
    const args = [key];
    // Add FIELDS keyword and field count - always required when fields parameter exists
    args.push("FIELDS", fields.length.toString());
    // Add field names
    args.push(...fields);
    return createCommand(RequestType.HPExpireTime, args);
}
/**
 * @internal
 */
function createDecr(key) {
    return createCommand(RequestType.Decr, [key]);
}
/**
 * @internal
 */
function createDecrBy(key, amount) {
    return createCommand(RequestType.DecrBy, [key, amount.toString()]);
}
/**
 * Enumeration defining the bitwise operation to use in the {@link BaseClient.bitop|bitop} command. Specifies the
 * bitwise operation to perform between the passed in keys.
 */
var BitwiseOperation;
(function (BitwiseOperation) {
    BitwiseOperation["AND"] = "AND";
    BitwiseOperation["OR"] = "OR";
    BitwiseOperation["XOR"] = "XOR";
    BitwiseOperation["NOT"] = "NOT";
})(BitwiseOperation || (exports.BitwiseOperation = BitwiseOperation = {}));
/**
 * @internal
 */
function createBitOp(operation, destination, keys) {
    return createCommand(RequestType.BitOp, [operation, destination, ...keys]);
}
/**
 * @internal
 */
function createGetBit(key, offset) {
    return createCommand(RequestType.GetBit, [key, offset.toString()]);
}
/**
 * @internal
 */
function createSetBit(key, offset, value) {
    return createCommand(RequestType.SetBit, [
        key,
        offset.toString(),
        value.toString(),
    ]);
}
/**
 * Represents a signed argument encoding.
 */
class SignedEncoding {
    static SIGNED_ENCODING_PREFIX = "i";
    encoding;
    /**
     * Creates an instance of SignedEncoding.
     *
     * @param encodingLength - The bit size of the encoding. Must be less than 65 bits long.
     */
    constructor(encodingLength) {
        this.encoding = `${SignedEncoding.SIGNED_ENCODING_PREFIX}${encodingLength.toString()}`;
    }
    toArg() {
        return this.encoding;
    }
}
exports.SignedEncoding = SignedEncoding;
/**
 * Represents an unsigned argument encoding.
 */
class UnsignedEncoding {
    static UNSIGNED_ENCODING_PREFIX = "u";
    encoding;
    /**
     * Creates an instance of UnsignedEncoding.
     *
     * @param encodingLength - The bit size of the encoding. Must be less than 64 bits long.
     */
    constructor(encodingLength) {
        this.encoding = `${UnsignedEncoding.UNSIGNED_ENCODING_PREFIX}${encodingLength.toString()}`;
    }
    toArg() {
        return this.encoding;
    }
}
exports.UnsignedEncoding = UnsignedEncoding;
/**
 * Represents an offset in an array of bits for the {@link BaseClient.bitfield|bitfield} or
 * {@link BaseClient.bitfieldReadOnly|bitfieldReadOnly} commands.
 *
 * For example, if we have the binary `01101001` with offset of 1 for an unsigned encoding of size 4, then the value
 * is 13 from `0(1101)001`.
 */
class BitOffset {
    offset;
    /**
     * Creates an instance of BitOffset.
     *
     * @param offset - The bit index offset in the array of bits. Must be greater than or equal to 0.
     */
    constructor(offset) {
        this.offset = offset.toString();
    }
    toArg() {
        return this.offset;
    }
}
exports.BitOffset = BitOffset;
/**
 * Represents an offset in an array of bits for the {@link BaseClient.bitfield|bitfield} or
 * {@link BaseClient.bitfieldReadOnly|bitfieldReadOnly} commands. The bit offset index is calculated as the numerical
 * value of the offset multiplied by the encoding value.
 *
 * For example, if we have the binary 01101001 with offset multiplier of 1 for an unsigned encoding of size 4, then the
 * value is 9 from `0110(1001)`.
 */
class BitOffsetMultiplier {
    static OFFSET_MULTIPLIER_PREFIX = "#";
    offset;
    /**
     * Creates an instance of BitOffsetMultiplier.
     *
     * @param offset - The offset in the array of bits, which will be multiplied by the encoding value to get the final
     *      bit index offset.
     */
    constructor(offset) {
        this.offset = `${BitOffsetMultiplier.OFFSET_MULTIPLIER_PREFIX}${offset.toString()}`;
    }
    toArg() {
        return this.offset;
    }
}
exports.BitOffsetMultiplier = BitOffsetMultiplier;
/**
 * Represents the "GET" subcommand for getting a value in the binary representation of the string stored in `key`.
 */
class BitFieldGet {
    static GET_COMMAND_STRING = "GET";
    encoding;
    offset;
    /**
     * Creates an instance of BitFieldGet.
     *
     * @param encoding - The bit encoding for the subcommand.
     * @param offset - The offset in the array of bits from which to get the value.
     */
    constructor(encoding, offset) {
        this.encoding = encoding;
        this.offset = offset;
    }
    toArgs() {
        return [
            BitFieldGet.GET_COMMAND_STRING,
            this.encoding.toArg(),
            this.offset.toArg(),
        ];
    }
}
exports.BitFieldGet = BitFieldGet;
/**
 * Represents the "SET" subcommand for setting bits in the binary representation of the string stored in `key`.
 */
class BitFieldSet {
    static SET_COMMAND_STRING = "SET";
    encoding;
    offset;
    value;
    /**
     * Creates an instance of BitFieldSet
     *
     * @param encoding - The bit encoding for the subcommand.
     * @param offset - The offset in the array of bits where the value will be set.
     * @param value - The value to set the bits in the binary value to.
     */
    constructor(encoding, offset, value) {
        this.encoding = encoding;
        this.offset = offset;
        this.value = value;
    }
    toArgs() {
        return [
            BitFieldSet.SET_COMMAND_STRING,
            this.encoding.toArg(),
            this.offset.toArg(),
            this.value.toString(),
        ];
    }
}
exports.BitFieldSet = BitFieldSet;
/**
 * Represents the "INCRBY" subcommand for increasing or decreasing bits in the binary representation of the string
 * stored in `key`.
 */
class BitFieldIncrBy {
    static INCRBY_COMMAND_STRING = "INCRBY";
    encoding;
    offset;
    increment;
    /**
     * Creates an instance of BitFieldIncrBy
     *
     * @param encoding - The bit encoding for the subcommand.
     * @param offset - The offset in the array of bits where the value will be incremented.
     * @param increment - The value to increment the bits in the binary value by.
     */
    constructor(encoding, offset, increment) {
        this.encoding = encoding;
        this.offset = offset;
        this.increment = increment;
    }
    toArgs() {
        return [
            BitFieldIncrBy.INCRBY_COMMAND_STRING,
            this.encoding.toArg(),
            this.offset.toArg(),
            this.increment.toString(),
        ];
    }
}
exports.BitFieldIncrBy = BitFieldIncrBy;
/**
 * Enumeration specifying bit overflow controls for the {@link BaseClient.bitfield|bitfield} command.
 */
var BitOverflowControl;
(function (BitOverflowControl) {
    /**
     * Performs modulo when overflows occur with unsigned encoding. When overflows occur with signed encoding, the value
     * restarts at the most negative value. When underflows occur with signed encoding, the value restarts at the most
     * positive value.
     */
    BitOverflowControl["WRAP"] = "WRAP";
    /**
     * Underflows remain set to the minimum value, and overflows remain set to the maximum value.
     */
    BitOverflowControl["SAT"] = "SAT";
    /**
     * Returns `None` when overflows occur.
     */
    BitOverflowControl["FAIL"] = "FAIL";
})(BitOverflowControl || (exports.BitOverflowControl = BitOverflowControl = {}));
/**
 * Represents the "OVERFLOW" subcommand that determines the result of the "SET" or "INCRBY"
 * {@link BaseClient.bitfield|bitfield} subcommands when an underflow or overflow occurs.
 */
class BitFieldOverflow {
    static OVERFLOW_COMMAND_STRING = "OVERFLOW";
    overflowControl;
    /**
     * Creates an instance of BitFieldOverflow.
     *
     * @param overflowControl - The desired overflow behavior.
     */
    constructor(overflowControl) {
        this.overflowControl = overflowControl;
    }
    toArgs() {
        return [BitFieldOverflow.OVERFLOW_COMMAND_STRING, this.overflowControl];
    }
}
exports.BitFieldOverflow = BitFieldOverflow;
/**
 * @internal
 */
function createBitField(key, subcommands, readOnly = false) {
    const requestType = readOnly
        ? RequestType.BitFieldReadOnly
        : RequestType.BitField;
    let args = [key];
    for (const subcommand of subcommands) {
        args = args.concat(subcommand.toArgs());
    }
    return createCommand(requestType, args);
}
/**
 * @internal
 */
function createHDel(key, fields) {
    return createCommand(RequestType.HDel, [key].concat(fields));
}
/**
 * @internal
 */
function createHMGet(key, fields) {
    return createCommand(RequestType.HMGet, [key].concat(fields));
}
/**
 * @internal
 */
function createHExists(key, field) {
    return createCommand(RequestType.HExists, [key, field]);
}
/**
 * @internal
 */
function createHGetAll(key) {
    return createCommand(RequestType.HGetAll, [key]);
}
/**
 * @internal
 */
function createLPush(key, elements) {
    return createCommand(RequestType.LPush, [key].concat(elements));
}
/**
 * @internal
 */
function createLPushX(key, elements) {
    return createCommand(RequestType.LPushX, [key].concat(elements));
}
/**
 * @internal
 */
function createLPop(key, count) {
    const args = count == undefined ? [key] : [key, count.toString()];
    return createCommand(RequestType.LPop, args);
}
/**
 * @internal
 */
function createLRange(key, start, end) {
    return createCommand(RequestType.LRange, [
        key,
        start.toString(),
        end.toString(),
    ]);
}
/**
 * @internal
 */
function createLLen(key) {
    return createCommand(RequestType.LLen, [key]);
}
/**
 * Enumeration representing element popping or adding direction for the List Based Commands.
 */
var ListDirection;
(function (ListDirection) {
    /**
     * Represents the option that elements should be popped from or added to the left side of a list.
     */
    ListDirection["LEFT"] = "LEFT";
    /**
     * Represents the option that elements should be popped from or added to the right side of a list.
     */
    ListDirection["RIGHT"] = "RIGHT";
})(ListDirection || (exports.ListDirection = ListDirection = {}));
/**
 * @internal
 */
function createLMove(source, destination, whereFrom, whereTo) {
    return createCommand(RequestType.LMove, [
        source,
        destination,
        whereFrom,
        whereTo,
    ]);
}
/**
 * @internal
 */
function createBLMove(source, destination, whereFrom, whereTo, timeout) {
    return createCommand(RequestType.BLMove, [
        source,
        destination,
        whereFrom,
        whereTo,
        timeout.toString(),
    ]);
}
/**
 * @internal
 */
function createLSet(key, index, element) {
    return createCommand(RequestType.LSet, [key, index.toString(), element]);
}
/**
 * @internal
 */
function createLTrim(key, start, end) {
    return createCommand(RequestType.LTrim, [
        key,
        start.toString(),
        end.toString(),
    ]);
}
/**
 * @internal
 */
function createLRem(key, count, element) {
    return createCommand(RequestType.LRem, [key, count.toString(), element]);
}
/**
 * @internal
 */
function createRPush(key, elements) {
    return createCommand(RequestType.RPush, [key].concat(elements));
}
/**
 * @internal
 */
function createRPushX(key, elements) {
    return createCommand(RequestType.RPushX, [key].concat(elements));
}
/**
 * @internal
 */
function createRPop(key, count) {
    const args = count == undefined ? [key] : [key, count.toString()];
    return createCommand(RequestType.RPop, args);
}
/**
 * @internal
 */
function createSAdd(key, members) {
    return createCommand(RequestType.SAdd, [key].concat(members));
}
/**
 * @internal
 */
function createSRem(key, members) {
    return createCommand(RequestType.SRem, [key].concat(members));
}
/**
 * @internal
 */
function createSScan(key, cursor, options) {
    let args = [key, cursor];
    if (options) {
        args = args.concat(convertBaseScanOptionsToArgsArray(options));
    }
    return createCommand(RequestType.SScan, args);
}
/**
 * @internal
 */
function createSMembers(key) {
    return createCommand(RequestType.SMembers, [key]);
}
/**
 *
 * @internal
 */
function createSMove(source, destination, member) {
    return createCommand(RequestType.SMove, [source, destination, member]);
}
/**
 * @internal
 */
function createSCard(key) {
    return createCommand(RequestType.SCard, [key]);
}
/**
 * @internal
 */
function createSInter(keys) {
    return createCommand(RequestType.SInter, keys);
}
/**
 * @internal
 */
function createSInterCard(keys, limit) {
    let args = keys;
    args.unshift(keys.length.toString());
    if (limit != undefined) {
        args = args.concat(["LIMIT", limit.toString()]);
    }
    return createCommand(RequestType.SInterCard, args);
}
/**
 * @internal
 */
function createSInterStore(destination, keys) {
    return createCommand(RequestType.SInterStore, [destination].concat(keys));
}
/**
 * @internal
 */
function createSDiff(keys) {
    return createCommand(RequestType.SDiff, keys);
}
/**
 * @internal
 */
function createSDiffStore(destination, keys) {
    return createCommand(RequestType.SDiffStore, [destination].concat(keys));
}
/**
 * @internal
 */
function createSUnion(keys) {
    return createCommand(RequestType.SUnion, keys);
}
/**
 * @internal
 */
function createSUnionStore(destination, keys) {
    return createCommand(RequestType.SUnionStore, [destination].concat(keys));
}
/**
 * @internal
 */
function createSIsMember(key, member) {
    return createCommand(RequestType.SIsMember, [key, member]);
}
/**
 * @internal
 */
function createSMIsMember(key, members) {
    return createCommand(RequestType.SMIsMember, [key].concat(members));
}
/**
 * @internal
 */
function createSPop(key, count) {
    const args = count == undefined ? [key] : [key, count.toString()];
    return createCommand(RequestType.SPop, args);
}
/**
 * @internal
 */
function createSRandMember(key, count) {
    const args = count == undefined ? [key] : [key, count.toString()];
    return createCommand(RequestType.SRandMember, args);
}
/**
 * @internal
 */
function createCustomCommand(args) {
    return createCommand(RequestType.CustomCommand, args);
}
/**
 * @internal
 */
function createHIncrBy(key, field, amount) {
    return createCommand(RequestType.HIncrBy, [key, field, amount.toString()]);
}
/**
 * @internal
 */
function createHIncrByFloat(key, field, amount) {
    return createCommand(RequestType.HIncrByFloat, [
        key,
        field,
        amount.toString(),
    ]);
}
/**
 * @internal
 */
function createHLen(key) {
    return createCommand(RequestType.HLen, [key]);
}
/**
 * @internal
 */
function createHVals(key) {
    return createCommand(RequestType.HVals, [key]);
}
/**
 * @internal
 */
function createExists(keys) {
    return createCommand(RequestType.Exists, keys);
}
/**
 * @internal
 */
function createUnlink(keys) {
    return createCommand(RequestType.Unlink, keys);
}
var ExpireOptions;
(function (ExpireOptions) {
    /**
     * `HasNoExpiry` - Sets expiry only when the key has no expiry.
     */
    ExpireOptions["HasNoExpiry"] = "NX";
    /**
     * `HasExistingExpiry` - Sets expiry only when the key has an existing expiry.
     */
    ExpireOptions["HasExistingExpiry"] = "XX";
    /**
     * `NewExpiryGreaterThanCurrent` - Sets expiry only when the new expiry is
     * greater than current one.
     */
    ExpireOptions["NewExpiryGreaterThanCurrent"] = "GT";
    /**
     * `NewExpiryLessThanCurrent` - Sets expiry only when the new expiry is less
     * than current one.
     */
    ExpireOptions["NewExpiryLessThanCurrent"] = "LT";
})(ExpireOptions || (exports.ExpireOptions = ExpireOptions = {}));
/**
 * @internal
 */
function createExpire(key, seconds, option) {
    const args = option == undefined
        ? [key, seconds.toString()]
        : [key, seconds.toString(), option];
    return createCommand(RequestType.Expire, args);
}
/**
 * @internal
 */
function createExpireAt(key, unixSeconds, option) {
    const args = option == undefined
        ? [key, unixSeconds.toString()]
        : [key, unixSeconds.toString(), option];
    return createCommand(RequestType.ExpireAt, args);
}
/**
 * @internal
 */
function createExpireTime(key) {
    return createCommand(RequestType.ExpireTime, [key]);
}
/**
 * @internal
 */
function createPExpire(key, milliseconds, option) {
    const args = option == undefined
        ? [key, milliseconds.toString()]
        : [key, milliseconds.toString(), option];
    return createCommand(RequestType.PExpire, args);
}
/**
 * @internal
 */
function createPExpireAt(key, unixMilliseconds, option) {
    const args = option == undefined
        ? [key, unixMilliseconds.toString()]
        : [key, unixMilliseconds.toString(), option];
    return createCommand(RequestType.PExpireAt, args);
}
/**
 * @internal
 */
function createPExpireTime(key) {
    return createCommand(RequestType.PExpireTime, [key]);
}
/**
 * @internal
 */
function createTTL(key) {
    return createCommand(RequestType.TTL, [key]);
}
/**
 * Options for updating elements of a sorted set key.
 */
var UpdateByScore;
(function (UpdateByScore) {
    /** Only update existing elements if the new score is less than the current score. */
    UpdateByScore["LESS_THAN"] = "LT";
    /** Only update existing elements if the new score is greater than the current score. */
    UpdateByScore["GREATER_THAN"] = "GT";
})(UpdateByScore || (exports.UpdateByScore = UpdateByScore = {}));
/**
 * @internal
 * Convert input from `Record` to `SortedSetDataType` to ensure the only one type.
 */
function convertElementsAndScores(membersAndScores) {
    if (!Array.isArray(membersAndScores)) {
        // convert Record<string, number> to SortedSetDataType
        return Object.entries(membersAndScores).map((element) => {
            return { element: element[0], score: element[1] };
        });
    }
    return membersAndScores;
}
/**
 * @internal
 */
function createZAdd(key, membersAndScores, options, incr = false) {
    const args = [key];
    if (options) {
        if (options.conditionalChange) {
            if (options.conditionalChange ===
                ConditionalChange.ONLY_IF_DOES_NOT_EXIST &&
                options.updateOptions) {
                throw new Error(`The GT, LT, and NX options are mutually exclusive. Cannot choose both ${options.updateOptions} and NX.`);
            }
            args.push(options.conditionalChange);
        }
        if (options.updateOptions) {
            args.push(options.updateOptions);
        }
        if (options.changed) {
            args.push("CH");
        }
    }
    if (incr) {
        args.push("INCR");
    }
    if (Array.isArray(membersAndScores)) {
        for (let i = 0, len = membersAndScores.length; i < len; i++) {
            const item = membersAndScores[i];
            args.push(item.score.toString(), item.element);
        }
    }
    else {
        const members = Object.keys(membersAndScores);
        for (let i = 0, len = members.length; i < len; i++) {
            const member = members[i];
            args.push(membersAndScores[member].toString(), member);
        }
    }
    return createCommand(RequestType.ZAdd, args);
}
/**
 * @internal
 */
function createZInterstore(destination, keys, aggregationType) {
    const args = createZCmdArgs(keys, {
        aggregationType,
        withScores: false,
        destination,
    });
    return createCommand(RequestType.ZInterStore, args);
}
/**
 * @internal
 */
function createZInter(keys, aggregationType, withScores) {
    const args = createZCmdArgs(keys, { aggregationType, withScores });
    return createCommand(RequestType.ZInter, args);
}
/**
 * @internal
 */
function createZUnion(keys, aggregationType, withScores) {
    const args = createZCmdArgs(keys, { aggregationType, withScores });
    return createCommand(RequestType.ZUnion, args);
}
/**
 * @internal
 * Helper function for Zcommands (ZInter, ZinterStore, ZUnion..) that arranges arguments in the server's required order.
 */
function createZCmdArgs(keys, options) {
    const args = [];
    const destination = options.destination;
    if (destination) {
        args.push(destination);
    }
    args.push(keys.length.toString());
    if (!Array.isArray(keys[0])) {
        // KeyWeight is an array
        args.push(...keys);
    }
    else {
        const weightsKeys = keys.map(([key]) => key);
        args.push(...weightsKeys);
        const weights = keys.map(([, weight]) => weight.toString());
        args.push("WEIGHTS", ...weights);
    }
    const aggregationType = options.aggregationType;
    if (aggregationType) {
        args.push("AGGREGATE", aggregationType);
    }
    if (options.withScores) {
        args.push("WITHSCORES");
    }
    return args;
}
/**
 * @internal
 */
function createZRem(key, members) {
    return createCommand(RequestType.ZRem, [key].concat(members));
}
/**
 * @internal
 */
function createZCard(key) {
    return createCommand(RequestType.ZCard, [key]);
}
/**
 * @internal
 */
function createZInterCard(keys, limit) {
    const args = keys;
    args.unshift(keys.length.toString());
    if (limit != undefined) {
        args.push("LIMIT", limit.toString());
    }
    return createCommand(RequestType.ZInterCard, args);
}
/**
 * @internal
 */
function createZDiff(keys) {
    const args = keys;
    args.unshift(keys.length.toString());
    return createCommand(RequestType.ZDiff, args);
}
/**
 * @internal
 */
function createZDiffWithScores(keys) {
    const args = keys;
    args.unshift(keys.length.toString());
    args.push("WITHSCORES");
    return createCommand(RequestType.ZDiff, args);
}
/**
 * @internal
 */
function createZDiffStore(destination, keys) {
    const args = [destination, keys.length.toString(), ...keys];
    return createCommand(RequestType.ZDiffStore, args);
}
/**
 * @internal
 */
function createZScore(key, member) {
    return createCommand(RequestType.ZScore, [key, member]);
}
/**
 * @internal
 */
function createZUnionStore(destination, keys, aggregationType) {
    const args = createZCmdArgs(keys, { destination, aggregationType });
    return createCommand(RequestType.ZUnionStore, args);
}
/**
 * @internal
 */
function createZMScore(key, members) {
    return createCommand(RequestType.ZMScore, [key, ...members]);
}
/**
 * @internal
 */
function createScan(cursor, options) {
    let args = [cursor];
    if (options) {
        args = args.concat(convertBaseScanOptionsToArgsArray(options));
    }
    if (options?.type) {
        args.push("TYPE", options.type);
    }
    return createCommand(RequestType.Scan, args);
}
var InfBoundary;
(function (InfBoundary) {
    /**
     * Positive infinity bound.
     */
    InfBoundary["PositiveInfinity"] = "+";
    /**
     * Negative infinity bound.
     */
    InfBoundary["NegativeInfinity"] = "-";
})(InfBoundary || (exports.InfBoundary = InfBoundary = {}));
/** Returns a string representation of a score boundary as a command argument. */
function getScoreBoundaryArg(score) {
    if (typeof score === "string") {
        // InfBoundary
        return score + "inf";
    }
    if (score.isInclusive == false) {
        return "(" + score.value.toString();
    }
    return score.value.toString();
}
/** Returns a string representation of a lex boundary as a command argument. */
function getLexBoundaryArg(score) {
    if (typeof score === "string") {
        // InfBoundary
        return score;
    }
    if (score.isInclusive == false) {
        return typeof score.value === "string"
            ? "(" + score.value
            : Buffer.concat([Buffer.from("("), score.value]);
    }
    return typeof score.value === "string"
        ? "[" + score.value
        : Buffer.concat([Buffer.from("["), score.value]);
}
/** Returns a string representation of a stream boundary as a command argument. */
function getStreamBoundaryArg(boundary) {
    if (typeof boundary === "string") {
        // InfBoundary
        return boundary;
    }
    if (boundary.isInclusive == false) {
        return "(" + boundary.value.toString();
    }
    return boundary.value.toString();
}
function createZRangeArgs(key, rangeQuery, reverse, withScores) {
    const args = [key];
    if (typeof rangeQuery.start != "number") {
        rangeQuery = rangeQuery;
        if (rangeQuery.type == "byLex") {
            args.push(getLexBoundaryArg(rangeQuery.start), getLexBoundaryArg(rangeQuery.end), "BYLEX");
        }
        else {
            args.push(getScoreBoundaryArg(rangeQuery.start), getScoreBoundaryArg(rangeQuery.end), "BYSCORE");
        }
    }
    else {
        args.push(rangeQuery.start.toString());
        args.push(rangeQuery.end.toString());
    }
    if (reverse) {
        args.push("REV");
    }
    if ("limit" in rangeQuery && rangeQuery.limit !== undefined) {
        args.push("LIMIT", String(rangeQuery.limit.offset), String(rangeQuery.limit.count));
    }
    if (withScores) {
        args.push("WITHSCORES");
    }
    return args;
}
/**
 * @internal
 */
function createZCount(key, minScore, maxScore) {
    const args = [
        key,
        getScoreBoundaryArg(minScore),
        getScoreBoundaryArg(maxScore),
    ];
    return createCommand(RequestType.ZCount, args);
}
/**
 * @internal
 */
function createZRange(key, rangeQuery, reverse = false) {
    const args = createZRangeArgs(key, rangeQuery, reverse, false);
    return createCommand(RequestType.ZRange, args);
}
/**
 * @internal
 */
function createZRangeWithScores(key, rangeQuery, reverse = false) {
    const args = createZRangeArgs(key, rangeQuery, reverse, true);
    return createCommand(RequestType.ZRange, args);
}
/**
 * @internal
 */
function createZRangeStore(destination, source, rangeQuery, reverse = false) {
    const args = [
        destination,
        ...createZRangeArgs(source, rangeQuery, reverse, false),
    ];
    return createCommand(RequestType.ZRangeStore, args);
}
/**
 * @internal
 */
function createType(key) {
    return createCommand(RequestType.Type, [key]);
}
/**
 * @internal
 */
function createStrlen(key) {
    return createCommand(RequestType.Strlen, [key]);
}
/**
 * @internal
 */
function createLIndex(key, index) {
    return createCommand(RequestType.LIndex, [key, index.toString()]);
}
/**
 * Defines where to insert new elements into a list.
 */
var InsertPosition;
(function (InsertPosition) {
    /**
     * Insert new element before the pivot.
     */
    InsertPosition["Before"] = "before";
    /**
     * Insert new element after the pivot.
     */
    InsertPosition["After"] = "after";
})(InsertPosition || (exports.InsertPosition = InsertPosition = {}));
/**
 * @internal
 */
function createLInsert(key, position, pivot, element) {
    return createCommand(RequestType.LInsert, [key, position, pivot, element]);
}
/**
 * @internal
 */
function createZPopMin(key, count) {
    const args = count == undefined ? [key] : [key, count.toString()];
    return createCommand(RequestType.ZPopMin, args);
}
/**
 * @internal
 */
function createZPopMax(key, count) {
    const args = count == undefined ? [key] : [key, count.toString()];
    return createCommand(RequestType.ZPopMax, args);
}
/**
 * @internal
 */
function createEcho(message) {
    return createCommand(RequestType.Echo, [message]);
}
/**
 * @internal
 */
function createPTTL(key) {
    return createCommand(RequestType.PTTL, [key]);
}
/**
 * @internal
 */
function createZRemRangeByRank(key, start, end) {
    return createCommand(RequestType.ZRemRangeByRank, [
        key,
        start.toString(),
        end.toString(),
    ]);
}
/**
 * @internal
 */
function createZRemRangeByLex(key, minLex, maxLex) {
    const args = [key, getLexBoundaryArg(minLex), getLexBoundaryArg(maxLex)];
    return createCommand(RequestType.ZRemRangeByLex, args);
}
/**
 * @internal
 */
function createZRemRangeByScore(key, minScore, maxScore) {
    const args = [
        key,
        getScoreBoundaryArg(minScore),
        getScoreBoundaryArg(maxScore),
    ];
    return createCommand(RequestType.ZRemRangeByScore, args);
}
/** @internal */
function createPersist(key) {
    return createCommand(RequestType.Persist, [key]);
}
/**
 * @internal
 */
function createZLexCount(key, minLex, maxLex) {
    const args = [key, getLexBoundaryArg(minLex), getLexBoundaryArg(maxLex)];
    return createCommand(RequestType.ZLexCount, args);
}
/** @internal */
function createZRank(key, member, withScores) {
    const args = [key, member];
    if (withScores) {
        args.push("WITHSCORE");
    }
    return createCommand(RequestType.ZRank, args);
}
function addTrimOptions(options, args) {
    if (options.method === "maxlen") {
        args.push("MAXLEN");
    }
    else if (options.method === "minid") {
        args.push("MINID");
    }
    if (options.exact) {
        args.push("=");
    }
    else {
        args.push("~");
    }
    if (options.method === "maxlen") {
        args.push(options.threshold.toString());
    }
    else if (options.method === "minid") {
        args.push(options.threshold);
    }
    if (options.limit) {
        args.push("LIMIT");
        args.push(options.limit.toString());
    }
}
/**
 * @internal
 */
function createXAdd(key, values, options) {
    const args = [key];
    if (options?.makeStream === false) {
        args.push("NOMKSTREAM");
    }
    if (options?.trim) {
        addTrimOptions(options.trim, args);
    }
    if (options?.id) {
        args.push(options.id);
    }
    else {
        args.push("*");
    }
    values.forEach(([field, value]) => {
        args.push(field);
        args.push(value);
    });
    return createCommand(RequestType.XAdd, args);
}
/**
 * @internal
 */
function createXDel(key, ids) {
    return createCommand(RequestType.XDel, [key, ...ids]);
}
/**
 * @internal
 */
function createXTrim(key, options) {
    const args = [key];
    addTrimOptions(options, args);
    return createCommand(RequestType.XTrim, args);
}
/**
 * @internal
 */
function createXRange(key, start, end, count) {
    const args = [key, getStreamBoundaryArg(start), getStreamBoundaryArg(end)];
    if (count !== undefined) {
        args.push("COUNT");
        args.push(count.toString());
    }
    return createCommand(RequestType.XRange, args);
}
/**
 * @internal
 */
function createXRevRange(key, start, end, count) {
    const args = [key, getStreamBoundaryArg(start), getStreamBoundaryArg(end)];
    if (count !== undefined) {
        args.push("COUNT");
        args.push(count.toString());
    }
    return createCommand(RequestType.XRevRange, args);
}
/**
 * @internal
 */
function createXGroupCreateConsumer(key, groupName, consumerName) {
    return createCommand(RequestType.XGroupCreateConsumer, [
        key,
        groupName,
        consumerName,
    ]);
}
/**
 * @internal
 */
function createXGroupDelConsumer(key, groupName, consumerName) {
    return createCommand(RequestType.XGroupDelConsumer, [
        key,
        groupName,
        consumerName,
    ]);
}
/**
 * @internal
 */
function createTime() {
    return createCommand(RequestType.Time, []);
}
/**
 * @internal
 */
function createPublish(message, channel, sharded = false) {
    const request = sharded ? RequestType.SPublish : RequestType.Publish;
    return createCommand(request, [channel, message]);
}
/**
 * @internal
 */
function createBRPop(keys, timeout) {
    const args = [...keys, timeout.toString()];
    return createCommand(RequestType.BRPop, args);
}
/**
 * @internal
 */
function createBLPop(keys, timeout) {
    const args = [...keys, timeout.toString()];
    return createCommand(RequestType.BLPop, args);
}
/**
 * @internal
 */
function createFCall(func, keys, args) {
    const params = [
        func,
        keys.length.toString(),
        ...keys,
        ...args,
    ];
    return createCommand(RequestType.FCall, params);
}
/**
 * @internal
 */
function createFCallReadOnly(func, keys, args) {
    const params = [
        func,
        keys.length.toString(),
        ...keys,
        ...args,
    ];
    return createCommand(RequestType.FCallReadOnly, params);
}
/**
 * @internal
 */
function createFunctionDelete(libraryCode) {
    return createCommand(RequestType.FunctionDelete, [libraryCode]);
}
/**
 * @internal
 */
function createFunctionFlush(mode) {
    if (mode) {
        return createCommand(RequestType.FunctionFlush, [mode.toString()]);
    }
    else {
        return createCommand(RequestType.FunctionFlush, []);
    }
}
/**
 * @internal
 */
function createFunctionLoad(libraryCode, replace) {
    const args = replace ? ["REPLACE", libraryCode] : [libraryCode];
    return createCommand(RequestType.FunctionLoad, args);
}
/**
 * @internal
 */
function createFunctionList(options) {
    const args = [];
    if (options) {
        if (options.libNamePattern) {
            args.push("LIBRARYNAME", options.libNamePattern);
        }
        if (options.withCode) {
            args.push("WITHCODE");
        }
    }
    return createCommand(RequestType.FunctionList, args);
}
/** @internal */
function createFunctionStats() {
    return createCommand(RequestType.FunctionStats, []);
}
/** @internal */
function createFunctionKill() {
    return createCommand(RequestType.FunctionKill, []);
}
/** @internal */
function createFunctionDump() {
    return createCommand(RequestType.FunctionDump, []);
}
/**
 * Option for `FUNCTION RESTORE` command: {@link GlideClient.functionRestore} and
 * {@link GlideClusterClient.functionRestore}.
 *
 * @see {@link https://valkey.io/commands/function-restore/"|valkey.io} for more details.
 */
var FunctionRestorePolicy;
(function (FunctionRestorePolicy) {
    /**
     * Appends the restored libraries to the existing libraries and aborts on collision. This is the
     * default policy.
     */
    FunctionRestorePolicy["APPEND"] = "APPEND";
    /** Deletes all existing libraries before restoring the payload. */
    FunctionRestorePolicy["FLUSH"] = "FLUSH";
    /**
     * Appends the restored libraries to the existing libraries, replacing any existing ones in case
     * of name collisions. Note that this policy doesn't prevent function name collisions, only
     * libraries.
     */
    FunctionRestorePolicy["REPLACE"] = "REPLACE";
})(FunctionRestorePolicy || (exports.FunctionRestorePolicy = FunctionRestorePolicy = {}));
/** @internal */
function createFunctionRestore(data, policy) {
    return createCommand(RequestType.FunctionRestore, policy ? [data, policy] : [data]);
}
/**
 * @internal
 */
function convertBitOptionsToArgs(options) {
    const args = [];
    if (!options)
        return args;
    args.push(options.start.toString());
    if (options.end !== undefined) {
        args.push(options.end.toString());
        if (options.indexType)
            args.push(options.indexType);
    }
    return args;
}
/**
 * @internal
 */
function createBitCount(key, options) {
    let args = [key];
    if (options) {
        const optionResults = convertBitOptionsToArgs(options);
        args = args.concat(optionResults);
    }
    return createCommand(RequestType.BitCount, args);
}
/**
 * Enumeration specifying if index arguments are BYTE indexes or BIT indexes.
 * Can be specified in {@link BitOffsetOptions}, which is an optional argument to the {@link BaseClient.bitcount|bitcount} command.
 * Can also be specified as an optional argument to the {@link BaseClient.bitposInverval|bitposInterval} command.
 *
 * since - Valkey version 7.0.0.
 */
var BitmapIndexType;
(function (BitmapIndexType) {
    /** Specifies that provided indexes are byte indexes. */
    BitmapIndexType["BYTE"] = "BYTE";
    /** Specifies that provided indexes are bit indexes. */
    BitmapIndexType["BIT"] = "BIT";
})(BitmapIndexType || (exports.BitmapIndexType = BitmapIndexType = {}));
/**
 * @internal
 */
function createBitPos(key, bit, options) {
    const args = [
        key,
        bit.toString(),
        ...convertBitOptionsToArgs(options),
    ];
    return createCommand(RequestType.BitPos, args);
}
/**
 * Defines flushing mode for {@link GlideClient.flushall}, {@link GlideClusterClient.flushall},
 *      {@link GlideClient.functionFlush}, {@link GlideClusterClient.functionFlush},
 *      {@link GlideClient.flushdb} and {@link GlideClusterClient.flushdb} commands.
 *
 * See https://valkey.io/commands/flushall/ and https://valkey.io/commands/flushdb/ for details.
 */
var FlushMode;
(function (FlushMode) {
    /**
     * Flushes synchronously.
     *
     * since Valkey version 6.2.0.
     */
    FlushMode["SYNC"] = "SYNC";
    /** Flushes asynchronously. */
    FlushMode["ASYNC"] = "ASYNC";
})(FlushMode || (exports.FlushMode = FlushMode = {}));
/**
 * @internal
 * This function converts an input from Record or GlideRecord types to GlideRecord.
 *
 * @param record - input record in either Record or GlideRecord types.
 * @returns same data in GlideRecord type.
 */
function convertKeysAndEntries(record) {
    if (!Array.isArray(record)) {
        return (0, BaseClient_1.convertRecordToGlideRecord)(record);
    }
    return record;
}
/** @internal */
function addReadOptions(options) {
    const args = [];
    if (options?.count !== undefined) {
        args.push("COUNT");
        args.push(options.count.toString());
    }
    if (options?.block !== undefined) {
        args.push("BLOCK");
        args.push(options.block.toString());
    }
    return args;
}
/** @internal */
function addStreamsArgs(keys_and_ids) {
    return [
        "STREAMS",
        ...keys_and_ids.map((e) => e.key),
        ...keys_and_ids.map((e) => e.value),
    ];
}
/**
 * @internal
 */
function createXRead(keys_and_ids, options) {
    const args = addReadOptions(options);
    args.push(...addStreamsArgs(keys_and_ids));
    return createCommand(RequestType.XRead, args);
}
/** @internal */
function createXReadGroup(group, consumer, keys_and_ids, options) {
    const args = ["GROUP", group, consumer];
    if (options) {
        args.push(...addReadOptions(options));
        if (options.noAck)
            args.push("NOACK");
    }
    args.push(...addStreamsArgs(keys_and_ids));
    return createCommand(RequestType.XReadGroup, args);
}
/**
 * @internal
 */
function createXInfoStream(key, options) {
    const args = [key];
    if (options != false) {
        args.push("FULL");
        if (typeof options === "number") {
            args.push("COUNT");
            args.push(options.toString());
        }
    }
    return createCommand(RequestType.XInfoStream, args);
}
/** @internal */
function createXInfoGroups(key) {
    return createCommand(RequestType.XInfoGroups, [key]);
}
/**
 * @internal
 */
function createXLen(key) {
    return createCommand(RequestType.XLen, [key]);
}
/** @internal */
function createXPending(key, group, options) {
    const args = [key, group];
    if (options) {
        if (options.minIdleTime !== undefined)
            args.push("IDLE", options.minIdleTime.toString());
        args.push(getStreamBoundaryArg(options.start), getStreamBoundaryArg(options.end), options.count.toString());
        if (options.consumer)
            args.push(options.consumer);
    }
    return createCommand(RequestType.XPending, args);
}
/** @internal */
function createXInfoConsumers(key, group) {
    return createCommand(RequestType.XInfoConsumers, [key, group]);
}
/** @internal */
function createXClaim(key, group, consumer, minIdleTime, ids, options, justId) {
    const args = [key, group, consumer, minIdleTime.toString(), ...ids];
    if (options) {
        if (options.idle !== undefined)
            args.push("IDLE", options.idle.toString());
        if (options.idleUnixTime !== undefined)
            args.push("TIME", options.idleUnixTime.toString());
        if (options.retryCount !== undefined)
            args.push("RETRYCOUNT", options.retryCount.toString());
        if (options.isForce)
            args.push("FORCE");
    }
    if (justId)
        args.push("JUSTID");
    return createCommand(RequestType.XClaim, args);
}
/** @internal */
function createXAutoClaim(key, group, consumer, minIdleTime, start, count, justId) {
    const args = [
        key,
        group,
        consumer,
        minIdleTime.toString(),
        start.toString(),
    ];
    if (count !== undefined)
        args.push("COUNT", count.toString());
    if (justId)
        args.push("JUSTID");
    return createCommand(RequestType.XAutoClaim, args);
}
/**
 * @internal
 */
function createXGroupCreate(key, groupName, id, options) {
    const args = [key, groupName, id];
    if (options) {
        if (options.mkStream) {
            args.push("MKSTREAM");
        }
        if (options.entriesRead) {
            args.push("ENTRIESREAD");
            args.push(options.entriesRead);
        }
    }
    return createCommand(RequestType.XGroupCreate, args);
}
/**
 * @internal
 */
function createXGroupDestroy(key, groupName) {
    return createCommand(RequestType.XGroupDestroy, [key, groupName]);
}
/**
 * @internal
 */
function createRename(key, newKey) {
    return createCommand(RequestType.Rename, [key, newKey]);
}
/**
 * @internal
 */
function createRenameNX(key, newKey) {
    return createCommand(RequestType.RenameNX, [key, newKey]);
}
/**
 * @internal
 */
function createPfAdd(key, elements) {
    const args = [key, ...elements];
    return createCommand(RequestType.PfAdd, args);
}
/**
 * @internal
 */
function createPfCount(keys) {
    return createCommand(RequestType.PfCount, keys);
}
/**
 * @internal
 */
function createPfMerge(destination, sourceKey) {
    return createCommand(RequestType.PfMerge, [destination, ...sourceKey]);
}
/**
 * @internal
 */
function createObjectEncoding(key) {
    return createCommand(RequestType.ObjectEncoding, [key]);
}
/**
 * @internal
 */
function createObjectFreq(key) {
    return createCommand(RequestType.ObjectFreq, [key]);
}
/**
 * @internal
 */
function createObjectIdletime(key) {
    return createCommand(RequestType.ObjectIdleTime, [key]);
}
/**
 * @internal
 */
function createObjectRefcount(key) {
    return createCommand(RequestType.ObjectRefCount, [key]);
}
/**
 * @internal
 */
function createLolwut(options) {
    const args = [];
    if (options) {
        if (options.version !== undefined) {
            args.push("VERSION", options.version.toString());
        }
        if (options.parameters !== undefined) {
            args.push(...options.parameters.map((param) => param.toString()));
        }
    }
    return createCommand(RequestType.Lolwut, args);
}
/**
 * @internal
 */
function createFlushAll(mode) {
    if (mode) {
        return createCommand(RequestType.FlushAll, [mode.toString()]);
    }
    else {
        return createCommand(RequestType.FlushAll, []);
    }
}
/**
 * @internal
 */
function createFlushDB(mode) {
    if (mode) {
        return createCommand(RequestType.FlushDB, [mode.toString()]);
    }
    else {
        return createCommand(RequestType.FlushDB, []);
    }
}
/**
 * @internal
 */
function createCopy(source, destination, options) {
    let args = [source, destination];
    if (options) {
        if (options.destinationDB !== undefined) {
            args = args.concat("DB", options.destinationDB.toString());
        }
        if (options.replace) {
            args.push("REPLACE");
        }
    }
    return createCommand(RequestType.Copy, args);
}
/**
 * @internal
 */
function createMove(key, dbIndex) {
    return createCommand(RequestType.Move, [key, dbIndex.toString()]);
}
/**
 * @internal
 */
function createDump(key) {
    return createCommand(RequestType.Dump, [key]);
}
/**
 * @internal
 */
function createRestore(key, ttl, value, options) {
    const args = [key, ttl.toString(), value];
    if (options) {
        if (options.idletime !== undefined && options.frequency !== undefined) {
            throw new Error(`syntax error: both IDLETIME and FREQ cannot be set at the same time.`);
        }
        if (options.replace) {
            args.push("REPLACE");
        }
        if (options.absttl) {
            args.push("ABSTTL");
        }
        if (options.idletime !== undefined) {
            args.push("IDLETIME", options.idletime.toString());
        }
        if (options.frequency !== undefined) {
            args.push("FREQ", options.frequency.toString());
        }
    }
    return createCommand(RequestType.Restore, args);
}
/**
 * @internal
 */
function createLPos(key, element, options) {
    const args = [key, element];
    if (options) {
        if (options.rank !== undefined) {
            args.push("RANK");
            args.push(options.rank.toString());
        }
        if (options.count !== undefined) {
            args.push("COUNT");
            args.push(options.count.toString());
        }
        if (options.maxLength !== undefined) {
            args.push("MAXLEN");
            args.push(options.maxLength.toString());
        }
    }
    return createCommand(RequestType.LPos, args);
}
/**
 * @internal
 */
function createDBSize() {
    return createCommand(RequestType.DBSize, []);
}
/**
 * An optional condition to the {@link BaseClient.geoadd | geoadd},
 * {@link BaseClient.zadd | zadd} and {@link BaseClient.set | set} commands.
 */
var ConditionalChange;
(function (ConditionalChange) {
    /**
     * Only update elements that already exist. Don't add new elements. Equivalent to `XX` in the Valkey API.
     */
    ConditionalChange["ONLY_IF_EXISTS"] = "XX";
    /**
     * Only add new elements. Don't update already existing elements. Equivalent to `NX` in the Valkey API.
     */
    ConditionalChange["ONLY_IF_DOES_NOT_EXIST"] = "NX";
})(ConditionalChange || (exports.ConditionalChange = ConditionalChange = {}));
/**
 * Field conditional change options for hash field expiration commands.
 * Used with HSETEX command to control field setting behavior.
 */
var HashFieldConditionalChange;
(function (HashFieldConditionalChange) {
    /**
     * Only set fields if all of them already exist. Equivalent to `FXX` in the Valkey API.
     */
    HashFieldConditionalChange["ONLY_IF_ALL_EXIST"] = "FXX";
    /**
     * Only set fields if none of them already exist. Equivalent to `FNX` in the Valkey API.
     */
    HashFieldConditionalChange["ONLY_IF_NONE_EXIST"] = "FNX";
})(HashFieldConditionalChange || (exports.HashFieldConditionalChange = HashFieldConditionalChange = {}));
/**
 * Expiration condition options for hash field expiration commands.
 * Used with HEXPIRE, HPEXPIRE, HEXPIREAT, and HPEXPIREAT commands to control expiration setting behavior.
 */
var HashExpirationCondition;
(function (HashExpirationCondition) {
    /**
     * Only set expiration when field has no expiration. Equivalent to `NX` in the Valkey API.
     */
    HashExpirationCondition["ONLY_IF_NO_EXPIRY"] = "NX";
    /**
     * Only set expiration when field has existing expiration. Equivalent to `XX` in the Valkey API.
     */
    HashExpirationCondition["ONLY_IF_HAS_EXPIRY"] = "XX";
    /**
     * Only set expiration when new expiration is greater than current. Equivalent to `GT` in the Valkey API.
     */
    HashExpirationCondition["ONLY_IF_GREATER_THAN_CURRENT"] = "GT";
    /**
     * Only set expiration when new expiration is less than current. Equivalent to `LT` in the Valkey API.
     */
    HashExpirationCondition["ONLY_IF_LESS_THAN_CURRENT"] = "LT";
})(HashExpirationCondition || (exports.HashExpirationCondition = HashExpirationCondition = {}));
/**
 * @internal
 */
function createGeoAdd(key, membersToGeospatialData, options) {
    let args = [key];
    if (options) {
        if (options.updateMode) {
            args.push(options.updateMode);
        }
        if (options.changed) {
            args.push("CH");
        }
    }
    membersToGeospatialData.forEach((coord, member) => {
        args = args.concat(coord.longitude.toString(), coord.latitude.toString(), member);
    });
    return createCommand(RequestType.GeoAdd, args);
}
/** Enumeration representing distance units options. */
var GeoUnit;
(function (GeoUnit) {
    /** Represents distance in meters. */
    GeoUnit["METERS"] = "m";
    /** Represents distance in kilometers. */
    GeoUnit["KILOMETERS"] = "km";
    /** Represents distance in miles. */
    GeoUnit["MILES"] = "mi";
    /** Represents distance in feet. */
    GeoUnit["FEET"] = "ft";
})(GeoUnit || (exports.GeoUnit = GeoUnit = {}));
/**
 * @internal
 */
function createGeoPos(key, members) {
    return createCommand(RequestType.GeoPos, [key].concat(members));
}
/**
 * @internal
 */
function createGeoDist(key, member1, member2, geoUnit) {
    const args = [key, member1, member2];
    if (geoUnit) {
        args.push(geoUnit);
    }
    return createCommand(RequestType.GeoDist, args);
}
/**
 * @internal
 */
function createGeoHash(key, members) {
    const args = [key].concat(members);
    return createCommand(RequestType.GeoHash, args);
}
/** Defines the sort order for nested results. */
var SortOrder;
(function (SortOrder) {
    /** Sort by ascending order. */
    SortOrder["ASC"] = "ASC";
    /** Sort by descending order. */
    SortOrder["DESC"] = "DESC";
})(SortOrder || (exports.SortOrder = SortOrder = {}));
/** @internal */
function createGeoSearch(key, searchFrom, searchBy, resultOptions) {
    const args = [key].concat(convertGeoSearchOptionsToArgs(searchFrom, searchBy, resultOptions));
    return createCommand(RequestType.GeoSearch, args);
}
/** @internal */
function createGeoSearchStore(destination, source, searchFrom, searchBy, resultOptions) {
    const args = [destination, source].concat(convertGeoSearchOptionsToArgs(searchFrom, searchBy, resultOptions));
    return createCommand(RequestType.GeoSearchStore, args);
}
function convertGeoSearchOptionsToArgs(searchFrom, searchBy, resultOptions) {
    let args = [];
    if ("position" in searchFrom) {
        args = args.concat("FROMLONLAT", searchFrom.position.longitude.toString(), searchFrom.position.latitude.toString());
    }
    else {
        args = args.concat("FROMMEMBER", searchFrom.member);
    }
    if ("radius" in searchBy) {
        args = args.concat("BYRADIUS", searchBy.radius.toString(), searchBy.unit);
    }
    else {
        args = args.concat("BYBOX", searchBy.width.toString(), searchBy.height.toString(), searchBy.unit);
    }
    if (resultOptions) {
        if ("withCoord" in resultOptions &&
            resultOptions.withCoord)
            args.push("WITHCOORD");
        if ("withDist" in resultOptions &&
            resultOptions.withDist)
            args.push("WITHDIST");
        if ("withHash" in resultOptions &&
            resultOptions.withHash)
            args.push("WITHHASH");
        if ("storeDist" in resultOptions &&
            resultOptions.storeDist)
            args.push("STOREDIST");
        if (resultOptions.count) {
            args.push("COUNT", resultOptions.count?.toString());
            if (resultOptions.isAny)
                args.push("ANY");
        }
        if (resultOptions.sortOrder)
            args.push(resultOptions.sortOrder);
    }
    return args;
}
/**
 * @internal
 */
function createZRevRank(key, member) {
    return createCommand(RequestType.ZRevRank, [key, member]);
}
/**
 * @internal
 */
function createZRevRankWithScore(key, member) {
    return createCommand(RequestType.ZRevRank, [key, member, "WITHSCORE"]);
}
/**
 * Mandatory option for zmpop.
 * Defines which elements to pop from the sorted set.
 */
var ScoreFilter;
(function (ScoreFilter) {
    /** Pop elements with the highest scores. */
    ScoreFilter["MAX"] = "MAX";
    /** Pop elements with the lowest scores. */
    ScoreFilter["MIN"] = "MIN";
})(ScoreFilter || (exports.ScoreFilter = ScoreFilter = {}));
/**
 * @internal
 */
function createZMPop(keys, modifier, count) {
    const args = keys;
    args.unshift(keys.length.toString());
    args.push(modifier);
    if (count !== undefined) {
        args.push("COUNT");
        args.push(count.toString());
    }
    return createCommand(RequestType.ZMPop, args);
}
/**
 * @internal
 */
function createBZMPop(keys, modifier, timeout, count) {
    const args = [
        timeout.toString(),
        keys.length.toString(),
        ...keys,
        modifier,
    ];
    if (count !== undefined) {
        args.push("COUNT");
        args.push(count.toString());
    }
    return createCommand(RequestType.BZMPop, args);
}
/**
 * @internal
 */
function createZIncrBy(key, increment, member) {
    return createCommand(RequestType.ZIncrBy, [
        key,
        increment.toString(),
        member,
    ]);
}
/** @internal */
function createSort(key, options, destination) {
    return createSortImpl(RequestType.Sort, key, options, destination);
}
/** @internal */
function createSortReadOnly(key, options) {
    return createSortImpl(RequestType.SortReadOnly, key, options);
}
/** @internal */
function createSortImpl(cmd, key, options, destination) {
    const args = [key];
    if (options) {
        if (options.limit) {
            args.push("LIMIT", options.limit.offset.toString(), options.limit.count.toString());
        }
        if (options.orderBy) {
            args.push(options.orderBy);
        }
        if (options.isAlpha) {
            args.push("ALPHA");
        }
        if (options.byPattern) {
            args.push("BY", options.byPattern);
        }
        if (options.getPatterns) {
            options.getPatterns.forEach((p) => args.push("GET", p));
        }
    }
    if (destination)
        args.push("STORE", destination);
    return createCommand(cmd, args);
}
/**
 * @internal
 */
function createHStrlen(key, field) {
    return createCommand(RequestType.HStrlen, [key, field]);
}
/** @internal */
function createHRandField(key, count, withValues) {
    const args = [key];
    if (count !== undefined)
        args.push(count.toString());
    if (withValues)
        args.push("WITHVALUES");
    return createCommand(RequestType.HRandField, args);
}
/**
 * @internal
 */
function createHScan(key, cursor, options) {
    let args = [key, cursor];
    if (options) {
        args = args.concat(convertBaseScanOptionsToArgsArray(options));
        if (options.noValues) {
            args.push("NOVALUES");
        }
    }
    return createCommand(RequestType.HScan, args);
}
/**
 * @internal
 */
function createZRandMember(key, count, withscores) {
    const args = [key];
    if (count !== undefined) {
        args.push(count.toString());
    }
    if (withscores) {
        args.push("WITHSCORES");
    }
    return createCommand(RequestType.ZRandMember, args);
}
/** @internal */
function createLastSave() {
    return createCommand(RequestType.LastSave, []);
}
/** @internal */
function createLCS(key1, key2, options) {
    const args = [key1, key2];
    if (options) {
        if (options.len)
            args.push("LEN");
        else if (options.idx) {
            args.push("IDX");
            if (options.idx.withMatchLen)
                args.push("WITHMATCHLEN");
            if (options.idx.minMatchLen !== undefined)
                args.push("MINMATCHLEN", options.idx.minMatchLen.toString());
        }
    }
    return createCommand(RequestType.LCS, args);
}
/**
 * @internal
 */
function createTouch(keys) {
    return createCommand(RequestType.Touch, keys);
}
/** @internal */
function createRandomKey() {
    return createCommand(RequestType.RandomKey, []);
}
/** @internal */
function createWatch(keys) {
    return createCommand(RequestType.Watch, keys);
}
/** @internal */
function createUnWatch() {
    return createCommand(RequestType.UnWatch, []);
}
/** @internal */
function createWait(numreplicas, timeout) {
    return createCommand(RequestType.Wait, [
        numreplicas.toString(),
        timeout.toString(),
    ]);
}
/**
 * @internal
 */
function convertBaseScanOptionsToArgsArray(options) {
    const args = [];
    if (options.match) {
        args.push("MATCH", options.match);
    }
    if (options.count !== undefined) {
        args.push("COUNT", options.count.toString());
    }
    return args;
}
/**
 * @internal
 */
function createZScan(key, cursor, options) {
    let args = [key, cursor];
    if (options) {
        args = args.concat(convertBaseScanOptionsToArgsArray(options));
        if (options.noScores) {
            args.push("NOSCORES");
        }
    }
    return createCommand(RequestType.ZScan, args);
}
/** @internal */
function createSetRange(key, offset, value) {
    return createCommand(RequestType.SetRange, [key, offset.toString(), value]);
}
/** @internal */
function createAppend(key, value) {
    return createCommand(RequestType.Append, [key, value]);
}
/**
 * @internal
 */
function createLMPop(keys, direction, count) {
    const args = [keys.length.toString(), ...keys, direction];
    if (count !== undefined) {
        args.push("COUNT");
        args.push(count.toString());
    }
    return createCommand(RequestType.LMPop, args);
}
/**
 * @internal
 */
function createBLMPop(keys, direction, timeout, count) {
    const args = [
        timeout.toString(),
        keys.length.toString(),
        ...keys,
        direction,
    ];
    if (count !== undefined) {
        args.push("COUNT");
        args.push(count.toString());
    }
    return createCommand(RequestType.BLMPop, args);
}
/**
 * @internal
 */
function createPubSubChannels(pattern) {
    return createCommand(RequestType.PubSubChannels, pattern ? [pattern] : []);
}
/**
 * @internal
 */
function createPubSubNumPat() {
    return createCommand(RequestType.PubSubNumPat, []);
}
/**
 * @internal
 */
function createPubSubNumSub(channels) {
    return createCommand(RequestType.PubSubNumSub, channels ? channels : []);
}
/**
 * @internal
 */
function createPubsubShardChannels(pattern) {
    return createCommand(RequestType.PubSubShardChannels, pattern ? [pattern] : []);
}
/**
 * @internal
 */
function createPubSubShardNumSub(channels) {
    return createCommand(RequestType.PubSubShardNumSub, channels ? channels : []);
}
/**
 * @internal
 */
function createBZPopMax(keys, timeout) {
    return createCommand(RequestType.BZPopMax, [...keys, timeout.toString()]);
}
/**
 * @internal
 */
function createBZPopMin(keys, timeout) {
    return createCommand(RequestType.BZPopMin, [...keys, timeout.toString()]);
}
/**
 * @internal
 */
function createScriptShow(sha1) {
    return createCommand(RequestType.ScriptShow, [sha1]);
}
/**
 * Time unit representation which is used in optional arguments for {@link BaseClient.getex|getex} and {@link BaseClient.set|set} command.
 */
var TimeUnit;
(function (TimeUnit) {
    /**
     * Set the specified expire time, in seconds. Equivalent to
     * `EX` in the VALKEY API.
     */
    TimeUnit["Seconds"] = "EX";
    /**
     * Set the specified expire time, in milliseconds. Equivalent
     * to `PX` in the VALKEY API.
     */
    TimeUnit["Milliseconds"] = "PX";
    /**
     * Set the specified Unix time at which the key will expire,
     * in seconds. Equivalent to `EXAT` in the VALKEY API.
     */
    TimeUnit["UnixSeconds"] = "EXAT";
    /**
     * Set the specified Unix time at which the key will expire,
     * in milliseconds. Equivalent to `PXAT` in the VALKEY API.
     */
    TimeUnit["UnixMilliseconds"] = "PXAT";
})(TimeUnit || (exports.TimeUnit = TimeUnit = {}));
/**
 * @internal
 */
function createGetEx(key, options) {
    const args = [key];
    if (options) {
        if (options !== "persist" && !Number.isInteger(options.duration)) {
            throw new Error(`Received expiry '${JSON.stringify(options.duration)}'. Count must be an integer`);
        }
        if (options === "persist") {
            args.push("PERSIST");
        }
        else {
            args.push(options.type, options.duration.toString());
        }
    }
    return createCommand(RequestType.GetEx, args);
}
/**
 * @internal
 */
function createXAck(key, group, ids) {
    return createCommand(RequestType.XAck, [key, group, ...ids]);
}
/**
 * @internal
 */
function createXGroupSetid(key, groupName, id, entriesRead) {
    const args = [key, groupName, id];
    if (entriesRead !== undefined) {
        args.push("ENTRIESREAD");
        args.push(entriesRead.toString());
    }
    return createCommand(RequestType.XGroupSetId, args);
}
/**
 * @internal
 */
function createScriptExists(sha1s) {
    return createCommand(RequestType.ScriptExists, sha1s);
}
/**
 * @internal
 */
function createScriptFlush(mode) {
    if (mode) {
        return createCommand(RequestType.ScriptFlush, [mode.toString()]);
    }
    else {
        return createCommand(RequestType.ScriptFlush, []);
    }
}
/** @internal */
function createScriptKill() {
    return createCommand(RequestType.ScriptKill, []);
}
