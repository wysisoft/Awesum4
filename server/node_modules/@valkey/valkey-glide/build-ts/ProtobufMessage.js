/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.command_request = (function() {

    /**
     * Namespace command_request.
     * @exports command_request
     * @namespace
     */
    var command_request = {};

    /**
     * SimpleRoutes enum.
     * @name command_request.SimpleRoutes
     * @enum {number}
     * @property {number} AllNodes=0 AllNodes value
     * @property {number} AllPrimaries=1 AllPrimaries value
     * @property {number} Random=2 Random value
     */
    command_request.SimpleRoutes = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "AllNodes"] = 0;
        values[valuesById[1] = "AllPrimaries"] = 1;
        values[valuesById[2] = "Random"] = 2;
        return values;
    })();

    /**
     * SlotTypes enum.
     * @name command_request.SlotTypes
     * @enum {number}
     * @property {number} Primary=0 Primary value
     * @property {number} Replica=1 Replica value
     */
    command_request.SlotTypes = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Primary"] = 0;
        values[valuesById[1] = "Replica"] = 1;
        return values;
    })();

    command_request.SlotIdRoute = (function() {

        /**
         * Properties of a SlotIdRoute.
         * @memberof command_request
         * @interface ISlotIdRoute
         * @property {command_request.SlotTypes|null} [slotType] SlotIdRoute slotType
         * @property {number|null} [slotId] SlotIdRoute slotId
         */

        /**
         * Constructs a new SlotIdRoute.
         * @memberof command_request
         * @classdesc Represents a SlotIdRoute.
         * @implements ISlotIdRoute
         * @constructor
         * @param {command_request.ISlotIdRoute=} [properties] Properties to set
         */
        function SlotIdRoute(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SlotIdRoute slotType.
         * @member {command_request.SlotTypes} slotType
         * @memberof command_request.SlotIdRoute
         * @instance
         */
        SlotIdRoute.prototype.slotType = 0;

        /**
         * SlotIdRoute slotId.
         * @member {number} slotId
         * @memberof command_request.SlotIdRoute
         * @instance
         */
        SlotIdRoute.prototype.slotId = 0;

        /**
         * Creates a new SlotIdRoute instance using the specified properties.
         * @function create
         * @memberof command_request.SlotIdRoute
         * @static
         * @param {command_request.ISlotIdRoute=} [properties] Properties to set
         * @returns {command_request.SlotIdRoute} SlotIdRoute instance
         */
        SlotIdRoute.create = function create(properties) {
            return new SlotIdRoute(properties);
        };

        /**
         * Encodes the specified SlotIdRoute message. Does not implicitly {@link command_request.SlotIdRoute.verify|verify} messages.
         * @function encode
         * @memberof command_request.SlotIdRoute
         * @static
         * @param {command_request.ISlotIdRoute} message SlotIdRoute message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SlotIdRoute.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.slotType != null && Object.hasOwnProperty.call(message, "slotType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.slotType);
            if (message.slotId != null && Object.hasOwnProperty.call(message, "slotId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.slotId);
            return writer;
        };

        /**
         * Encodes the specified SlotIdRoute message, length delimited. Does not implicitly {@link command_request.SlotIdRoute.verify|verify} messages.
         * @function encodeDelimited
         * @memberof command_request.SlotIdRoute
         * @static
         * @param {command_request.ISlotIdRoute} message SlotIdRoute message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SlotIdRoute.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
        };

        /**
         * Decodes a SlotIdRoute message from the specified reader or buffer.
         * @function decode
         * @memberof command_request.SlotIdRoute
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {command_request.SlotIdRoute} SlotIdRoute
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SlotIdRoute.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.command_request.SlotIdRoute();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.slotType = reader.int32();
                        break;
                    }
                case 2: {
                        message.slotId = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SlotIdRoute message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof command_request.SlotIdRoute
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {command_request.SlotIdRoute} SlotIdRoute
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SlotIdRoute.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Gets the default type url for SlotIdRoute
         * @function getTypeUrl
         * @memberof command_request.SlotIdRoute
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SlotIdRoute.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/command_request.SlotIdRoute";
        };

        return SlotIdRoute;
    })();

    command_request.SlotKeyRoute = (function() {

        /**
         * Properties of a SlotKeyRoute.
         * @memberof command_request
         * @interface ISlotKeyRoute
         * @property {command_request.SlotTypes|null} [slotType] SlotKeyRoute slotType
         * @property {string|null} [slotKey] SlotKeyRoute slotKey
         */

        /**
         * Constructs a new SlotKeyRoute.
         * @memberof command_request
         * @classdesc Represents a SlotKeyRoute.
         * @implements ISlotKeyRoute
         * @constructor
         * @param {command_request.ISlotKeyRoute=} [properties] Properties to set
         */
        function SlotKeyRoute(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SlotKeyRoute slotType.
         * @member {command_request.SlotTypes} slotType
         * @memberof command_request.SlotKeyRoute
         * @instance
         */
        SlotKeyRoute.prototype.slotType = 0;

        /**
         * SlotKeyRoute slotKey.
         * @member {string} slotKey
         * @memberof command_request.SlotKeyRoute
         * @instance
         */
        SlotKeyRoute.prototype.slotKey = "";

        /**
         * Creates a new SlotKeyRoute instance using the specified properties.
         * @function create
         * @memberof command_request.SlotKeyRoute
         * @static
         * @param {command_request.ISlotKeyRoute=} [properties] Properties to set
         * @returns {command_request.SlotKeyRoute} SlotKeyRoute instance
         */
        SlotKeyRoute.create = function create(properties) {
            return new SlotKeyRoute(properties);
        };

        /**
         * Encodes the specified SlotKeyRoute message. Does not implicitly {@link command_request.SlotKeyRoute.verify|verify} messages.
         * @function encode
         * @memberof command_request.SlotKeyRoute
         * @static
         * @param {command_request.ISlotKeyRoute} message SlotKeyRoute message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SlotKeyRoute.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.slotType != null && Object.hasOwnProperty.call(message, "slotType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.slotType);
            if (message.slotKey != null && Object.hasOwnProperty.call(message, "slotKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.slotKey);
            return writer;
        };

        /**
         * Encodes the specified SlotKeyRoute message, length delimited. Does not implicitly {@link command_request.SlotKeyRoute.verify|verify} messages.
         * @function encodeDelimited
         * @memberof command_request.SlotKeyRoute
         * @static
         * @param {command_request.ISlotKeyRoute} message SlotKeyRoute message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SlotKeyRoute.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
        };

        /**
         * Decodes a SlotKeyRoute message from the specified reader or buffer.
         * @function decode
         * @memberof command_request.SlotKeyRoute
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {command_request.SlotKeyRoute} SlotKeyRoute
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SlotKeyRoute.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.command_request.SlotKeyRoute();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.slotType = reader.int32();
                        break;
                    }
                case 2: {
                        message.slotKey = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SlotKeyRoute message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof command_request.SlotKeyRoute
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {command_request.SlotKeyRoute} SlotKeyRoute
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SlotKeyRoute.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Gets the default type url for SlotKeyRoute
         * @function getTypeUrl
         * @memberof command_request.SlotKeyRoute
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SlotKeyRoute.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/command_request.SlotKeyRoute";
        };

        return SlotKeyRoute;
    })();

    command_request.ByAddressRoute = (function() {

        /**
         * Properties of a ByAddressRoute.
         * @memberof command_request
         * @interface IByAddressRoute
         * @property {string|null} [host] ByAddressRoute host
         * @property {number|null} [port] ByAddressRoute port
         */

        /**
         * Constructs a new ByAddressRoute.
         * @memberof command_request
         * @classdesc Represents a ByAddressRoute.
         * @implements IByAddressRoute
         * @constructor
         * @param {command_request.IByAddressRoute=} [properties] Properties to set
         */
        function ByAddressRoute(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ByAddressRoute host.
         * @member {string} host
         * @memberof command_request.ByAddressRoute
         * @instance
         */
        ByAddressRoute.prototype.host = "";

        /**
         * ByAddressRoute port.
         * @member {number} port
         * @memberof command_request.ByAddressRoute
         * @instance
         */
        ByAddressRoute.prototype.port = 0;

        /**
         * Creates a new ByAddressRoute instance using the specified properties.
         * @function create
         * @memberof command_request.ByAddressRoute
         * @static
         * @param {command_request.IByAddressRoute=} [properties] Properties to set
         * @returns {command_request.ByAddressRoute} ByAddressRoute instance
         */
        ByAddressRoute.create = function create(properties) {
            return new ByAddressRoute(properties);
        };

        /**
         * Encodes the specified ByAddressRoute message. Does not implicitly {@link command_request.ByAddressRoute.verify|verify} messages.
         * @function encode
         * @memberof command_request.ByAddressRoute
         * @static
         * @param {command_request.IByAddressRoute} message ByAddressRoute message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ByAddressRoute.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.host != null && Object.hasOwnProperty.call(message, "host"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.host);
            if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.port);
            return writer;
        };

        /**
         * Encodes the specified ByAddressRoute message, length delimited. Does not implicitly {@link command_request.ByAddressRoute.verify|verify} messages.
         * @function encodeDelimited
         * @memberof command_request.ByAddressRoute
         * @static
         * @param {command_request.IByAddressRoute} message ByAddressRoute message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ByAddressRoute.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
        };

        /**
         * Decodes a ByAddressRoute message from the specified reader or buffer.
         * @function decode
         * @memberof command_request.ByAddressRoute
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {command_request.ByAddressRoute} ByAddressRoute
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ByAddressRoute.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.command_request.ByAddressRoute();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.host = reader.string();
                        break;
                    }
                case 2: {
                        message.port = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ByAddressRoute message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof command_request.ByAddressRoute
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {command_request.ByAddressRoute} ByAddressRoute
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ByAddressRoute.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Gets the default type url for ByAddressRoute
         * @function getTypeUrl
         * @memberof command_request.ByAddressRoute
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ByAddressRoute.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/command_request.ByAddressRoute";
        };

        return ByAddressRoute;
    })();

    command_request.Routes = (function() {

        /**
         * Properties of a Routes.
         * @memberof command_request
         * @interface IRoutes
         * @property {command_request.SimpleRoutes|null} [simpleRoutes] Routes simpleRoutes
         * @property {command_request.ISlotKeyRoute|null} [slotKeyRoute] Routes slotKeyRoute
         * @property {command_request.ISlotIdRoute|null} [slotIdRoute] Routes slotIdRoute
         * @property {command_request.IByAddressRoute|null} [byAddressRoute] Routes byAddressRoute
         */

        /**
         * Constructs a new Routes.
         * @memberof command_request
         * @classdesc Represents a Routes.
         * @implements IRoutes
         * @constructor
         * @param {command_request.IRoutes=} [properties] Properties to set
         */
        function Routes(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Routes simpleRoutes.
         * @member {command_request.SimpleRoutes|null|undefined} simpleRoutes
         * @memberof command_request.Routes
         * @instance
         */
        Routes.prototype.simpleRoutes = null;

        /**
         * Routes slotKeyRoute.
         * @member {command_request.ISlotKeyRoute|null|undefined} slotKeyRoute
         * @memberof command_request.Routes
         * @instance
         */
        Routes.prototype.slotKeyRoute = null;

        /**
         * Routes slotIdRoute.
         * @member {command_request.ISlotIdRoute|null|undefined} slotIdRoute
         * @memberof command_request.Routes
         * @instance
         */
        Routes.prototype.slotIdRoute = null;

        /**
         * Routes byAddressRoute.
         * @member {command_request.IByAddressRoute|null|undefined} byAddressRoute
         * @memberof command_request.Routes
         * @instance
         */
        Routes.prototype.byAddressRoute = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Routes value.
         * @member {"simpleRoutes"|"slotKeyRoute"|"slotIdRoute"|"byAddressRoute"|undefined} value
         * @memberof command_request.Routes
         * @instance
         */
        Object.defineProperty(Routes.prototype, "value", {
            get: $util.oneOfGetter($oneOfFields = ["simpleRoutes", "slotKeyRoute", "slotIdRoute", "byAddressRoute"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Routes instance using the specified properties.
         * @function create
         * @memberof command_request.Routes
         * @static
         * @param {command_request.IRoutes=} [properties] Properties to set
         * @returns {command_request.Routes} Routes instance
         */
        Routes.create = function create(properties) {
            return new Routes(properties);
        };

        /**
         * Encodes the specified Routes message. Does not implicitly {@link command_request.Routes.verify|verify} messages.
         * @function encode
         * @memberof command_request.Routes
         * @static
         * @param {command_request.IRoutes} message Routes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Routes.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.simpleRoutes != null && Object.hasOwnProperty.call(message, "simpleRoutes"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.simpleRoutes);
            if (message.slotKeyRoute != null && Object.hasOwnProperty.call(message, "slotKeyRoute"))
                $root.command_request.SlotKeyRoute.encode(message.slotKeyRoute, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.slotIdRoute != null && Object.hasOwnProperty.call(message, "slotIdRoute"))
                $root.command_request.SlotIdRoute.encode(message.slotIdRoute, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.byAddressRoute != null && Object.hasOwnProperty.call(message, "byAddressRoute"))
                $root.command_request.ByAddressRoute.encode(message.byAddressRoute, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Routes message, length delimited. Does not implicitly {@link command_request.Routes.verify|verify} messages.
         * @function encodeDelimited
         * @memberof command_request.Routes
         * @static
         * @param {command_request.IRoutes} message Routes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Routes.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
        };

        /**
         * Decodes a Routes message from the specified reader or buffer.
         * @function decode
         * @memberof command_request.Routes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {command_request.Routes} Routes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Routes.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.command_request.Routes();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.simpleRoutes = reader.int32();
                        break;
                    }
                case 2: {
                        message.slotKeyRoute = $root.command_request.SlotKeyRoute.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.slotIdRoute = $root.command_request.SlotIdRoute.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.byAddressRoute = $root.command_request.ByAddressRoute.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Routes message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof command_request.Routes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {command_request.Routes} Routes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Routes.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Gets the default type url for Routes
         * @function getTypeUrl
         * @memberof command_request.Routes
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Routes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/command_request.Routes";
        };

        return Routes;
    })();

    /**
     * RequestType enum.
     * @name command_request.RequestType
     * @enum {number}
     * @property {number} InvalidRequest=0 Invalid request type
     * @property {number} CustomCommand=1 An unknown command, where all arguments are defined by the user.
     * @property {number} BitCount=101 BitCount value
     * @property {number} BitField=102 BitField value
     * @property {number} BitFieldReadOnly=103 BitFieldReadOnly value
     * @property {number} BitOp=104 BitOp value
     * @property {number} BitPos=105 BitPos value
     * @property {number} GetBit=106 GetBit value
     * @property {number} SetBit=107 SetBit value
     * @property {number} Asking=201 Asking value
     * @property {number} ClusterAddSlots=202 ClusterAddSlots value
     * @property {number} ClusterAddSlotsRange=203 ClusterAddSlotsRange value
     * @property {number} ClusterBumpEpoch=204 ClusterBumpEpoch value
     * @property {number} ClusterCountFailureReports=205 ClusterCountFailureReports value
     * @property {number} ClusterCountKeysInSlot=206 ClusterCountKeysInSlot value
     * @property {number} ClusterDelSlots=207 ClusterDelSlots value
     * @property {number} ClusterDelSlotsRange=208 ClusterDelSlotsRange value
     * @property {number} ClusterFailover=209 ClusterFailover value
     * @property {number} ClusterFlushSlots=210 ClusterFlushSlots value
     * @property {number} ClusterForget=211 ClusterForget value
     * @property {number} ClusterGetKeysInSlot=212 ClusterGetKeysInSlot value
     * @property {number} ClusterInfo=213 ClusterInfo value
     * @property {number} ClusterKeySlot=214 ClusterKeySlot value
     * @property {number} ClusterLinks=215 ClusterLinks value
     * @property {number} ClusterMeet=216 ClusterMeet value
     * @property {number} ClusterMyId=217 ClusterMyId value
     * @property {number} ClusterMyShardId=218 ClusterMyShardId value
     * @property {number} ClusterNodes=219 ClusterNodes value
     * @property {number} ClusterReplicas=220 ClusterReplicas value
     * @property {number} ClusterReplicate=221 ClusterReplicate value
     * @property {number} ClusterReset=222 ClusterReset value
     * @property {number} ClusterSaveConfig=223 ClusterSaveConfig value
     * @property {number} ClusterSetConfigEpoch=224 ClusterSetConfigEpoch value
     * @property {number} ClusterSetslot=225 ClusterSetslot value
     * @property {number} ClusterShards=226 ClusterShards value
     * @property {number} ClusterSlaves=227 ClusterSlaves value
     * @property {number} ClusterSlots=228 ClusterSlots value
     * @property {number} ReadOnly=229 ReadOnly value
     * @property {number} ReadWrite=230 ReadWrite value
     * @property {number} Auth=301 Auth value
     * @property {number} ClientCaching=302 ClientCaching value
     * @property {number} ClientGetName=303 ClientGetName value
     * @property {number} ClientGetRedir=304 ClientGetRedir value
     * @property {number} ClientId=305 ClientId value
     * @property {number} ClientInfo=306 ClientInfo value
     * @property {number} ClientKillSimple=307 ClientKillSimple value
     * @property {number} ClientKill=308 ClientKill value
     * @property {number} ClientList=309 ClientList value
     * @property {number} ClientNoEvict=310 ClientNoEvict value
     * @property {number} ClientNoTouch=311 ClientNoTouch value
     * @property {number} ClientPause=312 ClientPause value
     * @property {number} ClientReply=313 ClientReply value
     * @property {number} ClientSetInfo=314 ClientSetInfo value
     * @property {number} ClientSetName=315 ClientSetName value
     * @property {number} ClientTracking=316 ClientTracking value
     * @property {number} ClientTrackingInfo=317 ClientTrackingInfo value
     * @property {number} ClientUnblock=318 ClientUnblock value
     * @property {number} ClientUnpause=319 ClientUnpause value
     * @property {number} Echo=320 Echo value
     * @property {number} Hello=321 Hello value
     * @property {number} Ping=322 Ping value
     * @property {number} Quit=323 Quit value
     * @property {number} Reset=324 Reset value
     * @property {number} Select=325 Select value
     * @property {number} Copy=401 Copy value
     * @property {number} Del=402 Del value
     * @property {number} Dump=403 Dump value
     * @property {number} Exists=404 Exists value
     * @property {number} Expire=405 Expire value
     * @property {number} ExpireAt=406 ExpireAt value
     * @property {number} ExpireTime=407 ExpireTime value
     * @property {number} Keys=408 Keys value
     * @property {number} Migrate=409 Migrate value
     * @property {number} Move=410 Move value
     * @property {number} ObjectEncoding=411 ObjectEncoding value
     * @property {number} ObjectFreq=412 ObjectFreq value
     * @property {number} ObjectIdleTime=413 ObjectIdleTime value
     * @property {number} ObjectRefCount=414 ObjectRefCount value
     * @property {number} Persist=415 Persist value
     * @property {number} PExpire=416 PExpire value
     * @property {number} PExpireAt=417 PExpireAt value
     * @property {number} PExpireTime=418 PExpireTime value
     * @property {number} PTTL=419 PTTL value
     * @property {number} RandomKey=420 RandomKey value
     * @property {number} Rename=421 Rename value
     * @property {number} RenameNX=422 RenameNX value
     * @property {number} Restore=423 Restore value
     * @property {number} Scan=424 Scan value
     * @property {number} Sort=425 Sort value
     * @property {number} SortReadOnly=426 SortReadOnly value
     * @property {number} Touch=427 Touch value
     * @property {number} TTL=428 TTL value
     * @property {number} Type=429 Type value
     * @property {number} Unlink=430 Unlink value
     * @property {number} Wait=431 Wait value
     * @property {number} WaitAof=432 WaitAof value
     * @property {number} GeoAdd=501 GeoAdd value
     * @property {number} GeoDist=502 GeoDist value
     * @property {number} GeoHash=503 GeoHash value
     * @property {number} GeoPos=504 GeoPos value
     * @property {number} GeoRadius=505 GeoRadius value
     * @property {number} GeoRadiusReadOnly=506 GeoRadiusReadOnly value
     * @property {number} GeoRadiusByMember=507 GeoRadiusByMember value
     * @property {number} GeoRadiusByMemberReadOnly=508 GeoRadiusByMemberReadOnly value
     * @property {number} GeoSearch=509 GeoSearch value
     * @property {number} GeoSearchStore=510 GeoSearchStore value
     * @property {number} HDel=601 HDel value
     * @property {number} HExists=602 HExists value
     * @property {number} HGet=603 HGet value
     * @property {number} HGetAll=604 HGetAll value
     * @property {number} HIncrBy=605 HIncrBy value
     * @property {number} HIncrByFloat=606 HIncrByFloat value
     * @property {number} HKeys=607 HKeys value
     * @property {number} HLen=608 HLen value
     * @property {number} HMGet=609 HMGet value
     * @property {number} HMSet=610 HMSet value
     * @property {number} HRandField=611 HRandField value
     * @property {number} HScan=612 HScan value
     * @property {number} HSet=613 HSet value
     * @property {number} HSetNX=614 HSetNX value
     * @property {number} HStrlen=615 HStrlen value
     * @property {number} HVals=616 HVals value
     * @property {number} HSetEx=617 HSetEx value
     * @property {number} HGetEx=618 HGetEx value
     * @property {number} HExpire=619 HExpire value
     * @property {number} HExpireAt=620 HExpireAt value
     * @property {number} HPExpire=621 HPExpire value
     * @property {number} HPExpireAt=622 HPExpireAt value
     * @property {number} HPersist=623 HPersist value
     * @property {number} HTtl=624 HTtl value
     * @property {number} HPTtl=625 HPTtl value
     * @property {number} HExpireTime=626 HExpireTime value
     * @property {number} HPExpireTime=627 HPExpireTime value
     * @property {number} PfAdd=701 PfAdd value
     * @property {number} PfCount=702 PfCount value
     * @property {number} PfMerge=703 PfMerge value
     * @property {number} BLMove=801 BLMove value
     * @property {number} BLMPop=802 BLMPop value
     * @property {number} BLPop=803 BLPop value
     * @property {number} BRPop=804 BRPop value
     * @property {number} BRPopLPush=805 BRPopLPush value
     * @property {number} LIndex=806 LIndex value
     * @property {number} LInsert=807 LInsert value
     * @property {number} LLen=808 LLen value
     * @property {number} LMove=809 LMove value
     * @property {number} LMPop=810 LMPop value
     * @property {number} LPop=811 LPop value
     * @property {number} LPos=812 LPos value
     * @property {number} LPush=813 LPush value
     * @property {number} LPushX=814 LPushX value
     * @property {number} LRange=815 LRange value
     * @property {number} LRem=816 LRem value
     * @property {number} LSet=817 LSet value
     * @property {number} LTrim=818 LTrim value
     * @property {number} RPop=819 RPop value
     * @property {number} RPopLPush=820 RPopLPush value
     * @property {number} RPush=821 RPush value
     * @property {number} RPushX=822 RPushX value
     * @property {number} PSubscribe=901 PSubscribe value
     * @property {number} Publish=902 Publish value
     * @property {number} PubSubChannels=903 PubSubChannels value
     * @property {number} PubSubNumPat=904 PubSubNumPat value
     * @property {number} PubSubNumSub=905 PubSubNumSub value
     * @property {number} PubSubShardChannels=906 PubSubShardChannels value
     * @property {number} PubSubShardNumSub=907 PubSubShardNumSub value
     * @property {number} PUnsubscribe=908 PUnsubscribe value
     * @property {number} SPublish=909 SPublish value
     * @property {number} SSubscribe=910 SSubscribe value
     * @property {number} Subscribe=911 Subscribe value
     * @property {number} SUnsubscribe=912 SUnsubscribe value
     * @property {number} Unsubscribe=913 Unsubscribe value
     * @property {number} Eval=1001 Eval value
     * @property {number} EvalReadOnly=1002 EvalReadOnly value
     * @property {number} EvalSha=1003 EvalSha value
     * @property {number} EvalShaReadOnly=1004 EvalShaReadOnly value
     * @property {number} FCall=1005 FCall value
     * @property {number} FCallReadOnly=1006 FCallReadOnly value
     * @property {number} FunctionDelete=1007 FunctionDelete value
     * @property {number} FunctionDump=1008 FunctionDump value
     * @property {number} FunctionFlush=1009 FunctionFlush value
     * @property {number} FunctionKill=1010 FunctionKill value
     * @property {number} FunctionList=1011 FunctionList value
     * @property {number} FunctionLoad=1012 FunctionLoad value
     * @property {number} FunctionRestore=1013 FunctionRestore value
     * @property {number} FunctionStats=1014 FunctionStats value
     * @property {number} ScriptDebug=1015 ScriptDebug value
     * @property {number} ScriptExists=1016 ScriptExists value
     * @property {number} ScriptFlush=1017 ScriptFlush value
     * @property {number} ScriptKill=1018 ScriptKill value
     * @property {number} ScriptLoad=1019 ScriptLoad value
     * @property {number} ScriptShow=1020 ScriptShow value
     * @property {number} AclCat=1101 AclCat value
     * @property {number} AclDelUser=1102 AclDelUser value
     * @property {number} AclDryRun=1103 AclDryRun value
     * @property {number} AclGenPass=1104 AclGenPass value
     * @property {number} AclGetUser=1105 AclGetUser value
     * @property {number} AclList=1106 AclList value
     * @property {number} AclLoad=1107 AclLoad value
     * @property {number} AclLog=1108 AclLog value
     * @property {number} AclSave=1109 AclSave value
     * @property {number} AclSetSser=1110 AclSetSser value
     * @property {number} AclUsers=1111 AclUsers value
     * @property {number} AclWhoami=1112 AclWhoami value
     * @property {number} BgRewriteAof=1113 BgRewriteAof value
     * @property {number} BgSave=1114 BgSave value
     * @property {number} Command_=1115 Command_ value
     * @property {number} CommandCount=1116 CommandCount value
     * @property {number} CommandDocs=1117 CommandDocs value
     * @property {number} CommandGetKeys=1118 CommandGetKeys value
     * @property {number} CommandGetKeysAndFlags=1119 CommandGetKeysAndFlags value
     * @property {number} CommandInfo=1120 CommandInfo value
     * @property {number} CommandList=1121 CommandList value
     * @property {number} ConfigGet=1122 ConfigGet value
     * @property {number} ConfigResetStat=1123 ConfigResetStat value
     * @property {number} ConfigRewrite=1124 ConfigRewrite value
     * @property {number} ConfigSet=1125 ConfigSet value
     * @property {number} DBSize=1126 DBSize value
     * @property {number} FailOver=1127 FailOver value
     * @property {number} FlushAll=1128 FlushAll value
     * @property {number} FlushDB=1129 FlushDB value
     * @property {number} Info=1130 Info value
     * @property {number} LastSave=1131 LastSave value
     * @property {number} LatencyDoctor=1132 LatencyDoctor value
     * @property {number} LatencyGraph=1133 LatencyGraph value
     * @property {number} LatencyHistogram=1134 LatencyHistogram value
     * @property {number} LatencyHistory=1135 LatencyHistory value
     * @property {number} LatencyLatest=1136 LatencyLatest value
     * @property {number} LatencyReset=1137 LatencyReset value
     * @property {number} Lolwut=1138 Lolwut value
     * @property {number} MemoryDoctor=1139 MemoryDoctor value
     * @property {number} MemoryMallocStats=1140 MemoryMallocStats value
     * @property {number} MemoryPurge=1141 MemoryPurge value
     * @property {number} MemoryStats=1142 MemoryStats value
     * @property {number} MemoryUsage=1143 MemoryUsage value
     * @property {number} ModuleList=1144 ModuleList value
     * @property {number} ModuleLoad=1145 ModuleLoad value
     * @property {number} ModuleLoadEx=1146 ModuleLoadEx value
     * @property {number} ModuleUnload=1147 ModuleUnload value
     * @property {number} Monitor=1148 Monitor value
     * @property {number} PSync=1149 PSync value
     * @property {number} ReplConf=1150 ReplConf value
     * @property {number} ReplicaOf=1151 ReplicaOf value
     * @property {number} RestoreAsking=1152 RestoreAsking value
     * @property {number} Role=1153 Role value
     * @property {number} Save=1154 Save value
     * @property {number} ShutDown=1155 ShutDown value
     * @property {number} SlaveOf=1156 SlaveOf value
     * @property {number} SlowLogGet=1157 SlowLogGet value
     * @property {number} SlowLogLen=1158 SlowLogLen value
     * @property {number} SlowLogReset=1159 SlowLogReset value
     * @property {number} SwapDb=1160 SwapDb value
     * @property {number} Sync=1161 Sync value
     * @property {number} Time=1162 Time value
     * @property {number} SAdd=1201 SAdd value
     * @property {number} SCard=1202 SCard value
     * @property {number} SDiff=1203 SDiff value
     * @property {number} SDiffStore=1204 SDiffStore value
     * @property {number} SInter=1205 SInter value
     * @property {number} SInterCard=1206 SInterCard value
     * @property {number} SInterStore=1207 SInterStore value
     * @property {number} SIsMember=1208 SIsMember value
     * @property {number} SMembers=1209 SMembers value
     * @property {number} SMIsMember=1210 SMIsMember value
     * @property {number} SMove=1211 SMove value
     * @property {number} SPop=1212 SPop value
     * @property {number} SRandMember=1213 SRandMember value
     * @property {number} SRem=1214 SRem value
     * @property {number} SScan=1215 SScan value
     * @property {number} SUnion=1216 SUnion value
     * @property {number} SUnionStore=1217 SUnionStore value
     * @property {number} BZMPop=1301 BZMPop value
     * @property {number} BZPopMax=1302 BZPopMax value
     * @property {number} BZPopMin=1303 BZPopMin value
     * @property {number} ZAdd=1304 ZAdd value
     * @property {number} ZCard=1305 ZCard value
     * @property {number} ZCount=1306 ZCount value
     * @property {number} ZDiff=1307 ZDiff value
     * @property {number} ZDiffStore=1308 ZDiffStore value
     * @property {number} ZIncrBy=1309 ZIncrBy value
     * @property {number} ZInter=1310 ZInter value
     * @property {number} ZInterCard=1311 ZInterCard value
     * @property {number} ZInterStore=1312 ZInterStore value
     * @property {number} ZLexCount=1313 ZLexCount value
     * @property {number} ZMPop=1314 ZMPop value
     * @property {number} ZMScore=1315 ZMScore value
     * @property {number} ZPopMax=1316 ZPopMax value
     * @property {number} ZPopMin=1317 ZPopMin value
     * @property {number} ZRandMember=1318 ZRandMember value
     * @property {number} ZRange=1319 ZRange value
     * @property {number} ZRangeByLex=1320 ZRangeByLex value
     * @property {number} ZRangeByScore=1321 ZRangeByScore value
     * @property {number} ZRangeStore=1322 ZRangeStore value
     * @property {number} ZRank=1323 ZRank value
     * @property {number} ZRem=1324 ZRem value
     * @property {number} ZRemRangeByLex=1325 ZRemRangeByLex value
     * @property {number} ZRemRangeByRank=1326 ZRemRangeByRank value
     * @property {number} ZRemRangeByScore=1327 ZRemRangeByScore value
     * @property {number} ZRevRange=1328 ZRevRange value
     * @property {number} ZRevRangeByLex=1329 ZRevRangeByLex value
     * @property {number} ZRevRangeByScore=1330 ZRevRangeByScore value
     * @property {number} ZRevRank=1331 ZRevRank value
     * @property {number} ZScan=1332 ZScan value
     * @property {number} ZScore=1333 ZScore value
     * @property {number} ZUnion=1334 ZUnion value
     * @property {number} ZUnionStore=1335 ZUnionStore value
     * @property {number} XAck=1401 XAck value
     * @property {number} XAdd=1402 XAdd value
     * @property {number} XAutoClaim=1403 XAutoClaim value
     * @property {number} XClaim=1404 XClaim value
     * @property {number} XDel=1405 XDel value
     * @property {number} XGroupCreate=1406 XGroupCreate value
     * @property {number} XGroupCreateConsumer=1407 XGroupCreateConsumer value
     * @property {number} XGroupDelConsumer=1408 XGroupDelConsumer value
     * @property {number} XGroupDestroy=1409 XGroupDestroy value
     * @property {number} XGroupSetId=1410 XGroupSetId value
     * @property {number} XInfoConsumers=1411 XInfoConsumers value
     * @property {number} XInfoGroups=1412 XInfoGroups value
     * @property {number} XInfoStream=1413 XInfoStream value
     * @property {number} XLen=1414 XLen value
     * @property {number} XPending=1415 XPending value
     * @property {number} XRange=1416 XRange value
     * @property {number} XRead=1417 XRead value
     * @property {number} XReadGroup=1418 XReadGroup value
     * @property {number} XRevRange=1419 XRevRange value
     * @property {number} XSetId=1420 XSetId value
     * @property {number} XTrim=1421 XTrim value
     * @property {number} Append=1501 Append value
     * @property {number} Decr=1502 Decr value
     * @property {number} DecrBy=1503 DecrBy value
     * @property {number} Get=1504 Get value
     * @property {number} GetDel=1505 GetDel value
     * @property {number} GetEx=1506 GetEx value
     * @property {number} GetRange=1507 GetRange value
     * @property {number} GetSet=1508 GetSet value
     * @property {number} Incr=1509 Incr value
     * @property {number} IncrBy=1510 IncrBy value
     * @property {number} IncrByFloat=1511 IncrByFloat value
     * @property {number} LCS=1512 LCS value
     * @property {number} MGet=1513 MGet value
     * @property {number} MSet=1514 MSet value
     * @property {number} MSetNX=1515 MSetNX value
     * @property {number} PSetEx=1516 PSetEx value
     * @property {number} Set=1517 Set value
     * @property {number} SetEx=1518 SetEx value
     * @property {number} SetNX=1519 SetNX value
     * @property {number} SetRange=1520 SetRange value
     * @property {number} Strlen=1521 Strlen value
     * @property {number} Substr=1522 Substr value
     * @property {number} Discard=1601 Discard value
     * @property {number} Exec=1602 Exec value
     * @property {number} Multi=1603 Multi value
     * @property {number} UnWatch=1604 UnWatch value
     * @property {number} Watch=1605 Watch value
     * @property {number} JsonArrAppend=2001 JsonArrAppend value
     * @property {number} JsonArrIndex=2002 JsonArrIndex value
     * @property {number} JsonArrInsert=2003 JsonArrInsert value
     * @property {number} JsonArrLen=2004 JsonArrLen value
     * @property {number} JsonArrPop=2005 JsonArrPop value
     * @property {number} JsonArrTrim=2006 JsonArrTrim value
     * @property {number} JsonClear=2007 JsonClear value
     * @property {number} JsonDebug=2008 JsonDebug value
     * @property {number} JsonDel=2009 JsonDel value
     * @property {number} JsonForget=2010 JsonForget value
     * @property {number} JsonGet=2011 JsonGet value
     * @property {number} JsonMGet=2012 JsonMGet value
     * @property {number} JsonNumIncrBy=2013 JsonNumIncrBy value
     * @property {number} JsonNumMultBy=2014 JsonNumMultBy value
     * @property {number} JsonObjKeys=2015 JsonObjKeys value
     * @property {number} JsonObjLen=2016 JsonObjLen value
     * @property {number} JsonResp=2017 JsonResp value
     * @property {number} JsonSet=2018 JsonSet value
     * @property {number} JsonStrAppend=2019 JsonStrAppend value
     * @property {number} JsonStrLen=2020 JsonStrLen value
     * @property {number} JsonToggle=2021 JsonToggle value
     * @property {number} JsonType=2022 JsonType value
     * @property {number} FtList=2101 FtList value
     * @property {number} FtAggregate=2102 FtAggregate value
     * @property {number} FtAliasAdd=2103 FtAliasAdd value
     * @property {number} FtAliasDel=2104 FtAliasDel value
     * @property {number} FtAliasList=2105 FtAliasList value
     * @property {number} FtAliasUpdate=2106 FtAliasUpdate value
     * @property {number} FtCreate=2107 FtCreate value
     * @property {number} FtDropIndex=2108 FtDropIndex value
     * @property {number} FtExplain=2109 FtExplain value
     * @property {number} FtExplainCli=2110 FtExplainCli value
     * @property {number} FtInfo=2111 FtInfo value
     * @property {number} FtProfile=2112 FtProfile value
     * @property {number} FtSearch=2113 FtSearch value
     */
    command_request.RequestType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "InvalidRequest"] = 0;
        values[valuesById[1] = "CustomCommand"] = 1;
        values[valuesById[101] = "BitCount"] = 101;
        values[valuesById[102] = "BitField"] = 102;
        values[valuesById[103] = "BitFieldReadOnly"] = 103;
        values[valuesById[104] = "BitOp"] = 104;
        values[valuesById[105] = "BitPos"] = 105;
        values[valuesById[106] = "GetBit"] = 106;
        values[valuesById[107] = "SetBit"] = 107;
        values[valuesById[201] = "Asking"] = 201;
        values[valuesById[202] = "ClusterAddSlots"] = 202;
        values[valuesById[203] = "ClusterAddSlotsRange"] = 203;
        values[valuesById[204] = "ClusterBumpEpoch"] = 204;
        values[valuesById[205] = "ClusterCountFailureReports"] = 205;
        values[valuesById[206] = "ClusterCountKeysInSlot"] = 206;
        values[valuesById[207] = "ClusterDelSlots"] = 207;
        values[valuesById[208] = "ClusterDelSlotsRange"] = 208;
        values[valuesById[209] = "ClusterFailover"] = 209;
        values[valuesById[210] = "ClusterFlushSlots"] = 210;
        values[valuesById[211] = "ClusterForget"] = 211;
        values[valuesById[212] = "ClusterGetKeysInSlot"] = 212;
        values[valuesById[213] = "ClusterInfo"] = 213;
        values[valuesById[214] = "ClusterKeySlot"] = 214;
        values[valuesById[215] = "ClusterLinks"] = 215;
        values[valuesById[216] = "ClusterMeet"] = 216;
        values[valuesById[217] = "ClusterMyId"] = 217;
        values[valuesById[218] = "ClusterMyShardId"] = 218;
        values[valuesById[219] = "ClusterNodes"] = 219;
        values[valuesById[220] = "ClusterReplicas"] = 220;
        values[valuesById[221] = "ClusterReplicate"] = 221;
        values[valuesById[222] = "ClusterReset"] = 222;
        values[valuesById[223] = "ClusterSaveConfig"] = 223;
        values[valuesById[224] = "ClusterSetConfigEpoch"] = 224;
        values[valuesById[225] = "ClusterSetslot"] = 225;
        values[valuesById[226] = "ClusterShards"] = 226;
        values[valuesById[227] = "ClusterSlaves"] = 227;
        values[valuesById[228] = "ClusterSlots"] = 228;
        values[valuesById[229] = "ReadOnly"] = 229;
        values[valuesById[230] = "ReadWrite"] = 230;
        values[valuesById[301] = "Auth"] = 301;
        values[valuesById[302] = "ClientCaching"] = 302;
        values[valuesById[303] = "ClientGetName"] = 303;
        values[valuesById[304] = "ClientGetRedir"] = 304;
        values[valuesById[305] = "ClientId"] = 305;
        values[valuesById[306] = "ClientInfo"] = 306;
        values[valuesById[307] = "ClientKillSimple"] = 307;
        values[valuesById[308] = "ClientKill"] = 308;
        values[valuesById[309] = "ClientList"] = 309;
        values[valuesById[310] = "ClientNoEvict"] = 310;
        values[valuesById[311] = "ClientNoTouch"] = 311;
        values[valuesById[312] = "ClientPause"] = 312;
        values[valuesById[313] = "ClientReply"] = 313;
        values[valuesById[314] = "ClientSetInfo"] = 314;
        values[valuesById[315] = "ClientSetName"] = 315;
        values[valuesById[316] = "ClientTracking"] = 316;
        values[valuesById[317] = "ClientTrackingInfo"] = 317;
        values[valuesById[318] = "ClientUnblock"] = 318;
        values[valuesById[319] = "ClientUnpause"] = 319;
        values[valuesById[320] = "Echo"] = 320;
        values[valuesById[321] = "Hello"] = 321;
        values[valuesById[322] = "Ping"] = 322;
        values[valuesById[323] = "Quit"] = 323;
        values[valuesById[324] = "Reset"] = 324;
        values[valuesById[325] = "Select"] = 325;
        values[valuesById[401] = "Copy"] = 401;
        values[valuesById[402] = "Del"] = 402;
        values[valuesById[403] = "Dump"] = 403;
        values[valuesById[404] = "Exists"] = 404;
        values[valuesById[405] = "Expire"] = 405;
        values[valuesById[406] = "ExpireAt"] = 406;
        values[valuesById[407] = "ExpireTime"] = 407;
        values[valuesById[408] = "Keys"] = 408;
        values[valuesById[409] = "Migrate"] = 409;
        values[valuesById[410] = "Move"] = 410;
        values[valuesById[411] = "ObjectEncoding"] = 411;
        values[valuesById[412] = "ObjectFreq"] = 412;
        values[valuesById[413] = "ObjectIdleTime"] = 413;
        values[valuesById[414] = "ObjectRefCount"] = 414;
        values[valuesById[415] = "Persist"] = 415;
        values[valuesById[416] = "PExpire"] = 416;
        values[valuesById[417] = "PExpireAt"] = 417;
        values[valuesById[418] = "PExpireTime"] = 418;
        values[valuesById[419] = "PTTL"] = 419;
        values[valuesById[420] = "RandomKey"] = 420;
        values[valuesById[421] = "Rename"] = 421;
        values[valuesById[422] = "RenameNX"] = 422;
        values[valuesById[423] = "Restore"] = 423;
        values[valuesById[424] = "Scan"] = 424;
        values[valuesById[425] = "Sort"] = 425;
        values[valuesById[426] = "SortReadOnly"] = 426;
        values[valuesById[427] = "Touch"] = 427;
        values[valuesById[428] = "TTL"] = 428;
        values[valuesById[429] = "Type"] = 429;
        values[valuesById[430] = "Unlink"] = 430;
        values[valuesById[431] = "Wait"] = 431;
        values[valuesById[432] = "WaitAof"] = 432;
        values[valuesById[501] = "GeoAdd"] = 501;
        values[valuesById[502] = "GeoDist"] = 502;
        values[valuesById[503] = "GeoHash"] = 503;
        values[valuesById[504] = "GeoPos"] = 504;
        values[valuesById[505] = "GeoRadius"] = 505;
        values[valuesById[506] = "GeoRadiusReadOnly"] = 506;
        values[valuesById[507] = "GeoRadiusByMember"] = 507;
        values[valuesById[508] = "GeoRadiusByMemberReadOnly"] = 508;
        values[valuesById[509] = "GeoSearch"] = 509;
        values[valuesById[510] = "GeoSearchStore"] = 510;
        values[valuesById[601] = "HDel"] = 601;
        values[valuesById[602] = "HExists"] = 602;
        values[valuesById[603] = "HGet"] = 603;
        values[valuesById[604] = "HGetAll"] = 604;
        values[valuesById[605] = "HIncrBy"] = 605;
        values[valuesById[606] = "HIncrByFloat"] = 606;
        values[valuesById[607] = "HKeys"] = 607;
        values[valuesById[608] = "HLen"] = 608;
        values[valuesById[609] = "HMGet"] = 609;
        values[valuesById[610] = "HMSet"] = 610;
        values[valuesById[611] = "HRandField"] = 611;
        values[valuesById[612] = "HScan"] = 612;
        values[valuesById[613] = "HSet"] = 613;
        values[valuesById[614] = "HSetNX"] = 614;
        values[valuesById[615] = "HStrlen"] = 615;
        values[valuesById[616] = "HVals"] = 616;
        values[valuesById[617] = "HSetEx"] = 617;
        values[valuesById[618] = "HGetEx"] = 618;
        values[valuesById[619] = "HExpire"] = 619;
        values[valuesById[620] = "HExpireAt"] = 620;
        values[valuesById[621] = "HPExpire"] = 621;
        values[valuesById[622] = "HPExpireAt"] = 622;
        values[valuesById[623] = "HPersist"] = 623;
        values[valuesById[624] = "HTtl"] = 624;
        values[valuesById[625] = "HPTtl"] = 625;
        values[valuesById[626] = "HExpireTime"] = 626;
        values[valuesById[627] = "HPExpireTime"] = 627;
        values[valuesById[701] = "PfAdd"] = 701;
        values[valuesById[702] = "PfCount"] = 702;
        values[valuesById[703] = "PfMerge"] = 703;
        values[valuesById[801] = "BLMove"] = 801;
        values[valuesById[802] = "BLMPop"] = 802;
        values[valuesById[803] = "BLPop"] = 803;
        values[valuesById[804] = "BRPop"] = 804;
        values[valuesById[805] = "BRPopLPush"] = 805;
        values[valuesById[806] = "LIndex"] = 806;
        values[valuesById[807] = "LInsert"] = 807;
        values[valuesById[808] = "LLen"] = 808;
        values[valuesById[809] = "LMove"] = 809;
        values[valuesById[810] = "LMPop"] = 810;
        values[valuesById[811] = "LPop"] = 811;
        values[valuesById[812] = "LPos"] = 812;
        values[valuesById[813] = "LPush"] = 813;
        values[valuesById[814] = "LPushX"] = 814;
        values[valuesById[815] = "LRange"] = 815;
        values[valuesById[816] = "LRem"] = 816;
        values[valuesById[817] = "LSet"] = 817;
        values[valuesById[818] = "LTrim"] = 818;
        values[valuesById[819] = "RPop"] = 819;
        values[valuesById[820] = "RPopLPush"] = 820;
        values[valuesById[821] = "RPush"] = 821;
        values[valuesById[822] = "RPushX"] = 822;
        values[valuesById[901] = "PSubscribe"] = 901;
        values[valuesById[902] = "Publish"] = 902;
        values[valuesById[903] = "PubSubChannels"] = 903;
        values[valuesById[904] = "PubSubNumPat"] = 904;
        values[valuesById[905] = "PubSubNumSub"] = 905;
        values[valuesById[906] = "PubSubShardChannels"] = 906;
        values[valuesById[907] = "PubSubShardNumSub"] = 907;
        values[valuesById[908] = "PUnsubscribe"] = 908;
        values[valuesById[909] = "SPublish"] = 909;
        values[valuesById[910] = "SSubscribe"] = 910;
        values[valuesById[911] = "Subscribe"] = 911;
        values[valuesById[912] = "SUnsubscribe"] = 912;
        values[valuesById[913] = "Unsubscribe"] = 913;
        values[valuesById[1001] = "Eval"] = 1001;
        values[valuesById[1002] = "EvalReadOnly"] = 1002;
        values[valuesById[1003] = "EvalSha"] = 1003;
        values[valuesById[1004] = "EvalShaReadOnly"] = 1004;
        values[valuesById[1005] = "FCall"] = 1005;
        values[valuesById[1006] = "FCallReadOnly"] = 1006;
        values[valuesById[1007] = "FunctionDelete"] = 1007;
        values[valuesById[1008] = "FunctionDump"] = 1008;
        values[valuesById[1009] = "FunctionFlush"] = 1009;
        values[valuesById[1010] = "FunctionKill"] = 1010;
        values[valuesById[1011] = "FunctionList"] = 1011;
        values[valuesById[1012] = "FunctionLoad"] = 1012;
        values[valuesById[1013] = "FunctionRestore"] = 1013;
        values[valuesById[1014] = "FunctionStats"] = 1014;
        values[valuesById[1015] = "ScriptDebug"] = 1015;
        values[valuesById[1016] = "ScriptExists"] = 1016;
        values[valuesById[1017] = "ScriptFlush"] = 1017;
        values[valuesById[1018] = "ScriptKill"] = 1018;
        values[valuesById[1019] = "ScriptLoad"] = 1019;
        values[valuesById[1020] = "ScriptShow"] = 1020;
        values[valuesById[1101] = "AclCat"] = 1101;
        values[valuesById[1102] = "AclDelUser"] = 1102;
        values[valuesById[1103] = "AclDryRun"] = 1103;
        values[valuesById[1104] = "AclGenPass"] = 1104;
        values[valuesById[1105] = "AclGetUser"] = 1105;
        values[valuesById[1106] = "AclList"] = 1106;
        values[valuesById[1107] = "AclLoad"] = 1107;
        values[valuesById[1108] = "AclLog"] = 1108;
        values[valuesById[1109] = "AclSave"] = 1109;
        values[valuesById[1110] = "AclSetSser"] = 1110;
        values[valuesById[1111] = "AclUsers"] = 1111;
        values[valuesById[1112] = "AclWhoami"] = 1112;
        values[valuesById[1113] = "BgRewriteAof"] = 1113;
        values[valuesById[1114] = "BgSave"] = 1114;
        values[valuesById[1115] = "Command_"] = 1115;
        values[valuesById[1116] = "CommandCount"] = 1116;
        values[valuesById[1117] = "CommandDocs"] = 1117;
        values[valuesById[1118] = "CommandGetKeys"] = 1118;
        values[valuesById[1119] = "CommandGetKeysAndFlags"] = 1119;
        values[valuesById[1120] = "CommandInfo"] = 1120;
        values[valuesById[1121] = "CommandList"] = 1121;
        values[valuesById[1122] = "ConfigGet"] = 1122;
        values[valuesById[1123] = "ConfigResetStat"] = 1123;
        values[valuesById[1124] = "ConfigRewrite"] = 1124;
        values[valuesById[1125] = "ConfigSet"] = 1125;
        values[valuesById[1126] = "DBSize"] = 1126;
        values[valuesById[1127] = "FailOver"] = 1127;
        values[valuesById[1128] = "FlushAll"] = 1128;
        values[valuesById[1129] = "FlushDB"] = 1129;
        values[valuesById[1130] = "Info"] = 1130;
        values[valuesById[1131] = "LastSave"] = 1131;
        values[valuesById[1132] = "LatencyDoctor"] = 1132;
        values[valuesById[1133] = "LatencyGraph"] = 1133;
        values[valuesById[1134] = "LatencyHistogram"] = 1134;
        values[valuesById[1135] = "LatencyHistory"] = 1135;
        values[valuesById[1136] = "LatencyLatest"] = 1136;
        values[valuesById[1137] = "LatencyReset"] = 1137;
        values[valuesById[1138] = "Lolwut"] = 1138;
        values[valuesById[1139] = "MemoryDoctor"] = 1139;
        values[valuesById[1140] = "MemoryMallocStats"] = 1140;
        values[valuesById[1141] = "MemoryPurge"] = 1141;
        values[valuesById[1142] = "MemoryStats"] = 1142;
        values[valuesById[1143] = "MemoryUsage"] = 1143;
        values[valuesById[1144] = "ModuleList"] = 1144;
        values[valuesById[1145] = "ModuleLoad"] = 1145;
        values[valuesById[1146] = "ModuleLoadEx"] = 1146;
        values[valuesById[1147] = "ModuleUnload"] = 1147;
        values[valuesById[1148] = "Monitor"] = 1148;
        values[valuesById[1149] = "PSync"] = 1149;
        values[valuesById[1150] = "ReplConf"] = 1150;
        values[valuesById[1151] = "ReplicaOf"] = 1151;
        values[valuesById[1152] = "RestoreAsking"] = 1152;
        values[valuesById[1153] = "Role"] = 1153;
        values[valuesById[1154] = "Save"] = 1154;
        values[valuesById[1155] = "ShutDown"] = 1155;
        values[valuesById[1156] = "SlaveOf"] = 1156;
        values[valuesById[1157] = "SlowLogGet"] = 1157;
        values[valuesById[1158] = "SlowLogLen"] = 1158;
        values[valuesById[1159] = "SlowLogReset"] = 1159;
        values[valuesById[1160] = "SwapDb"] = 1160;
        values[valuesById[1161] = "Sync"] = 1161;
        values[valuesById[1162] = "Time"] = 1162;
        values[valuesById[1201] = "SAdd"] = 1201;
        values[valuesById[1202] = "SCard"] = 1202;
        values[valuesById[1203] = "SDiff"] = 1203;
        values[valuesById[1204] = "SDiffStore"] = 1204;
        values[valuesById[1205] = "SInter"] = 1205;
        values[valuesById[1206] = "SInterCard"] = 1206;
        values[valuesById[1207] = "SInterStore"] = 1207;
        values[valuesById[1208] = "SIsMember"] = 1208;
        values[valuesById[1209] = "SMembers"] = 1209;
        values[valuesById[1210] = "SMIsMember"] = 1210;
        values[valuesById[1211] = "SMove"] = 1211;
        values[valuesById[1212] = "SPop"] = 1212;
        values[valuesById[1213] = "SRandMember"] = 1213;
        values[valuesById[1214] = "SRem"] = 1214;
        values[valuesById[1215] = "SScan"] = 1215;
        values[valuesById[1216] = "SUnion"] = 1216;
        values[valuesById[1217] = "SUnionStore"] = 1217;
        values[valuesById[1301] = "BZMPop"] = 1301;
        values[valuesById[1302] = "BZPopMax"] = 1302;
        values[valuesById[1303] = "BZPopMin"] = 1303;
        values[valuesById[1304] = "ZAdd"] = 1304;
        values[valuesById[1305] = "ZCard"] = 1305;
        values[valuesById[1306] = "ZCount"] = 1306;
        values[valuesById[1307] = "ZDiff"] = 1307;
        values[valuesById[1308] = "ZDiffStore"] = 1308;
        values[valuesById[1309] = "ZIncrBy"] = 1309;
        values[valuesById[1310] = "ZInter"] = 1310;
        values[valuesById[1311] = "ZInterCard"] = 1311;
        values[valuesById[1312] = "ZInterStore"] = 1312;
        values[valuesById[1313] = "ZLexCount"] = 1313;
        values[valuesById[1314] = "ZMPop"] = 1314;
        values[valuesById[1315] = "ZMScore"] = 1315;
        values[valuesById[1316] = "ZPopMax"] = 1316;
        values[valuesById[1317] = "ZPopMin"] = 1317;
        values[valuesById[1318] = "ZRandMember"] = 1318;
        values[valuesById[1319] = "ZRange"] = 1319;
        values[valuesById[1320] = "ZRangeByLex"] = 1320;
        values[valuesById[1321] = "ZRangeByScore"] = 1321;
        values[valuesById[1322] = "ZRangeStore"] = 1322;
        values[valuesById[1323] = "ZRank"] = 1323;
        values[valuesById[1324] = "ZRem"] = 1324;
        values[valuesById[1325] = "ZRemRangeByLex"] = 1325;
        values[valuesById[1326] = "ZRemRangeByRank"] = 1326;
        values[valuesById[1327] = "ZRemRangeByScore"] = 1327;
        values[valuesById[1328] = "ZRevRange"] = 1328;
        values[valuesById[1329] = "ZRevRangeByLex"] = 1329;
        values[valuesById[1330] = "ZRevRangeByScore"] = 1330;
        values[valuesById[1331] = "ZRevRank"] = 1331;
        values[valuesById[1332] = "ZScan"] = 1332;
        values[valuesById[1333] = "ZScore"] = 1333;
        values[valuesById[1334] = "ZUnion"] = 1334;
        values[valuesById[1335] = "ZUnionStore"] = 1335;
        values[valuesById[1401] = "XAck"] = 1401;
        values[valuesById[1402] = "XAdd"] = 1402;
        values[valuesById[1403] = "XAutoClaim"] = 1403;
        values[valuesById[1404] = "XClaim"] = 1404;
        values[valuesById[1405] = "XDel"] = 1405;
        values[valuesById[1406] = "XGroupCreate"] = 1406;
        values[valuesById[1407] = "XGroupCreateConsumer"] = 1407;
        values[valuesById[1408] = "XGroupDelConsumer"] = 1408;
        values[valuesById[1409] = "XGroupDestroy"] = 1409;
        values[valuesById[1410] = "XGroupSetId"] = 1410;
        values[valuesById[1411] = "XInfoConsumers"] = 1411;
        values[valuesById[1412] = "XInfoGroups"] = 1412;
        values[valuesById[1413] = "XInfoStream"] = 1413;
        values[valuesById[1414] = "XLen"] = 1414;
        values[valuesById[1415] = "XPending"] = 1415;
        values[valuesById[1416] = "XRange"] = 1416;
        values[valuesById[1417] = "XRead"] = 1417;
        values[valuesById[1418] = "XReadGroup"] = 1418;
        values[valuesById[1419] = "XRevRange"] = 1419;
        values[valuesById[1420] = "XSetId"] = 1420;
        values[valuesById[1421] = "XTrim"] = 1421;
        values[valuesById[1501] = "Append"] = 1501;
        values[valuesById[1502] = "Decr"] = 1502;
        values[valuesById[1503] = "DecrBy"] = 1503;
        values[valuesById[1504] = "Get"] = 1504;
        values[valuesById[1505] = "GetDel"] = 1505;
        values[valuesById[1506] = "GetEx"] = 1506;
        values[valuesById[1507] = "GetRange"] = 1507;
        values[valuesById[1508] = "GetSet"] = 1508;
        values[valuesById[1509] = "Incr"] = 1509;
        values[valuesById[1510] = "IncrBy"] = 1510;
        values[valuesById[1511] = "IncrByFloat"] = 1511;
        values[valuesById[1512] = "LCS"] = 1512;
        values[valuesById[1513] = "MGet"] = 1513;
        values[valuesById[1514] = "MSet"] = 1514;
        values[valuesById[1515] = "MSetNX"] = 1515;
        values[valuesById[1516] = "PSetEx"] = 1516;
        values[valuesById[1517] = "Set"] = 1517;
        values[valuesById[1518] = "SetEx"] = 1518;
        values[valuesById[1519] = "SetNX"] = 1519;
        values[valuesById[1520] = "SetRange"] = 1520;
        values[valuesById[1521] = "Strlen"] = 1521;
        values[valuesById[1522] = "Substr"] = 1522;
        values[valuesById[1601] = "Discard"] = 1601;
        values[valuesById[1602] = "Exec"] = 1602;
        values[valuesById[1603] = "Multi"] = 1603;
        values[valuesById[1604] = "UnWatch"] = 1604;
        values[valuesById[1605] = "Watch"] = 1605;
        values[valuesById[2001] = "JsonArrAppend"] = 2001;
        values[valuesById[2002] = "JsonArrIndex"] = 2002;
        values[valuesById[2003] = "JsonArrInsert"] = 2003;
        values[valuesById[2004] = "JsonArrLen"] = 2004;
        values[valuesById[2005] = "JsonArrPop"] = 2005;
        values[valuesById[2006] = "JsonArrTrim"] = 2006;
        values[valuesById[2007] = "JsonClear"] = 2007;
        values[valuesById[2008] = "JsonDebug"] = 2008;
        values[valuesById[2009] = "JsonDel"] = 2009;
        values[valuesById[2010] = "JsonForget"] = 2010;
        values[valuesById[2011] = "JsonGet"] = 2011;
        values[valuesById[2012] = "JsonMGet"] = 2012;
        values[valuesById[2013] = "JsonNumIncrBy"] = 2013;
        values[valuesById[2014] = "JsonNumMultBy"] = 2014;
        values[valuesById[2015] = "JsonObjKeys"] = 2015;
        values[valuesById[2016] = "JsonObjLen"] = 2016;
        values[valuesById[2017] = "JsonResp"] = 2017;
        values[valuesById[2018] = "JsonSet"] = 2018;
        values[valuesById[2019] = "JsonStrAppend"] = 2019;
        values[valuesById[2020] = "JsonStrLen"] = 2020;
        values[valuesById[2021] = "JsonToggle"] = 2021;
        values[valuesById[2022] = "JsonType"] = 2022;
        values[valuesById[2101] = "FtList"] = 2101;
        values[valuesById[2102] = "FtAggregate"] = 2102;
        values[valuesById[2103] = "FtAliasAdd"] = 2103;
        values[valuesById[2104] = "FtAliasDel"] = 2104;
        values[valuesById[2105] = "FtAliasList"] = 2105;
        values[valuesById[2106] = "FtAliasUpdate"] = 2106;
        values[valuesById[2107] = "FtCreate"] = 2107;
        values[valuesById[2108] = "FtDropIndex"] = 2108;
        values[valuesById[2109] = "FtExplain"] = 2109;
        values[valuesById[2110] = "FtExplainCli"] = 2110;
        values[valuesById[2111] = "FtInfo"] = 2111;
        values[valuesById[2112] = "FtProfile"] = 2112;
        values[valuesById[2113] = "FtSearch"] = 2113;
        return values;
    })();

    command_request.Command = (function() {

        /**
         * Properties of a Command.
         * @memberof command_request
         * @interface ICommand
         * @property {command_request.RequestType|null} [requestType] Command requestType
         * @property {command_request.Command.IArgsArray|null} [argsArray] Command argsArray
         * @property {number|Long|null} [argsVecPointer] Command argsVecPointer
         */

        /**
         * Constructs a new Command.
         * @memberof command_request
         * @classdesc Represents a Command.
         * @implements ICommand
         * @constructor
         * @param {command_request.ICommand=} [properties] Properties to set
         */
        function Command(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Command requestType.
         * @member {command_request.RequestType} requestType
         * @memberof command_request.Command
         * @instance
         */
        Command.prototype.requestType = 0;

        /**
         * Command argsArray.
         * @member {command_request.Command.IArgsArray|null|undefined} argsArray
         * @memberof command_request.Command
         * @instance
         */
        Command.prototype.argsArray = null;

        /**
         * Command argsVecPointer.
         * @member {number|Long|null|undefined} argsVecPointer
         * @memberof command_request.Command
         * @instance
         */
        Command.prototype.argsVecPointer = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Command args.
         * @member {"argsArray"|"argsVecPointer"|undefined} args
         * @memberof command_request.Command
         * @instance
         */
        Object.defineProperty(Command.prototype, "args", {
            get: $util.oneOfGetter($oneOfFields = ["argsArray", "argsVecPointer"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Command instance using the specified properties.
         * @function create
         * @memberof command_request.Command
         * @static
         * @param {command_request.ICommand=} [properties] Properties to set
         * @returns {command_request.Command} Command instance
         */
        Command.create = function create(properties) {
            return new Command(properties);
        };

        /**
         * Encodes the specified Command message. Does not implicitly {@link command_request.Command.verify|verify} messages.
         * @function encode
         * @memberof command_request.Command
         * @static
         * @param {command_request.ICommand} message Command message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Command.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.requestType != null && Object.hasOwnProperty.call(message, "requestType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.requestType);
            if (message.argsArray != null && Object.hasOwnProperty.call(message, "argsArray"))
                $root.command_request.Command.ArgsArray.encode(message.argsArray, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.argsVecPointer != null && Object.hasOwnProperty.call(message, "argsVecPointer"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.argsVecPointer);
            return writer;
        };

        /**
         * Encodes the specified Command message, length delimited. Does not implicitly {@link command_request.Command.verify|verify} messages.
         * @function encodeDelimited
         * @memberof command_request.Command
         * @static
         * @param {command_request.ICommand} message Command message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Command.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
        };

        /**
         * Decodes a Command message from the specified reader or buffer.
         * @function decode
         * @memberof command_request.Command
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {command_request.Command} Command
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Command.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.command_request.Command();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.requestType = reader.int32();
                        break;
                    }
                case 2: {
                        message.argsArray = $root.command_request.Command.ArgsArray.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.argsVecPointer = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Command message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof command_request.Command
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {command_request.Command} Command
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Command.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Gets the default type url for Command
         * @function getTypeUrl
         * @memberof command_request.Command
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Command.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/command_request.Command";
        };

        Command.ArgsArray = (function() {

            /**
             * Properties of an ArgsArray.
             * @memberof command_request.Command
             * @interface IArgsArray
             * @property {Array.<Uint8Array>|null} [args] ArgsArray args
             */

            /**
             * Constructs a new ArgsArray.
             * @memberof command_request.Command
             * @classdesc Represents an ArgsArray.
             * @implements IArgsArray
             * @constructor
             * @param {command_request.Command.IArgsArray=} [properties] Properties to set
             */
            function ArgsArray(properties) {
                this.args = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ArgsArray args.
             * @member {Array.<Uint8Array>} args
             * @memberof command_request.Command.ArgsArray
             * @instance
             */
            ArgsArray.prototype.args = $util.emptyArray;

            /**
             * Creates a new ArgsArray instance using the specified properties.
             * @function create
             * @memberof command_request.Command.ArgsArray
             * @static
             * @param {command_request.Command.IArgsArray=} [properties] Properties to set
             * @returns {command_request.Command.ArgsArray} ArgsArray instance
             */
            ArgsArray.create = function create(properties) {
                return new ArgsArray(properties);
            };

            /**
             * Encodes the specified ArgsArray message. Does not implicitly {@link command_request.Command.ArgsArray.verify|verify} messages.
             * @function encode
             * @memberof command_request.Command.ArgsArray
             * @static
             * @param {command_request.Command.IArgsArray} message ArgsArray message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ArgsArray.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.args != null && message.args.length)
                    for (var i = 0; i < message.args.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.args[i]);
                return writer;
            };

            /**
             * Encodes the specified ArgsArray message, length delimited. Does not implicitly {@link command_request.Command.ArgsArray.verify|verify} messages.
             * @function encodeDelimited
             * @memberof command_request.Command.ArgsArray
             * @static
             * @param {command_request.Command.IArgsArray} message ArgsArray message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ArgsArray.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
            };

            /**
             * Decodes an ArgsArray message from the specified reader or buffer.
             * @function decode
             * @memberof command_request.Command.ArgsArray
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {command_request.Command.ArgsArray} ArgsArray
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ArgsArray.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.command_request.Command.ArgsArray();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.args && message.args.length))
                                message.args = [];
                            message.args.push(reader.bytes());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ArgsArray message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof command_request.Command.ArgsArray
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {command_request.Command.ArgsArray} ArgsArray
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ArgsArray.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Gets the default type url for ArgsArray
             * @function getTypeUrl
             * @memberof command_request.Command.ArgsArray
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ArgsArray.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/command_request.Command.ArgsArray";
            };

            return ArgsArray;
        })();

        return Command;
    })();

    command_request.ScriptInvocationPointers = (function() {

        /**
         * Properties of a ScriptInvocationPointers.
         * @memberof command_request
         * @interface IScriptInvocationPointers
         * @property {string|null} [hash] ScriptInvocationPointers hash
         * @property {number|Long|null} [keysPointer] ScriptInvocationPointers keysPointer
         * @property {number|Long|null} [argsPointer] ScriptInvocationPointers argsPointer
         */

        /**
         * Constructs a new ScriptInvocationPointers.
         * @memberof command_request
         * @classdesc Represents a ScriptInvocationPointers.
         * @implements IScriptInvocationPointers
         * @constructor
         * @param {command_request.IScriptInvocationPointers=} [properties] Properties to set
         */
        function ScriptInvocationPointers(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ScriptInvocationPointers hash.
         * @member {string} hash
         * @memberof command_request.ScriptInvocationPointers
         * @instance
         */
        ScriptInvocationPointers.prototype.hash = "";

        /**
         * ScriptInvocationPointers keysPointer.
         * @member {number|Long|null|undefined} keysPointer
         * @memberof command_request.ScriptInvocationPointers
         * @instance
         */
        ScriptInvocationPointers.prototype.keysPointer = null;

        /**
         * ScriptInvocationPointers argsPointer.
         * @member {number|Long|null|undefined} argsPointer
         * @memberof command_request.ScriptInvocationPointers
         * @instance
         */
        ScriptInvocationPointers.prototype.argsPointer = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * ScriptInvocationPointers _keysPointer.
         * @member {"keysPointer"|undefined} _keysPointer
         * @memberof command_request.ScriptInvocationPointers
         * @instance
         */
        Object.defineProperty(ScriptInvocationPointers.prototype, "_keysPointer", {
            get: $util.oneOfGetter($oneOfFields = ["keysPointer"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * ScriptInvocationPointers _argsPointer.
         * @member {"argsPointer"|undefined} _argsPointer
         * @memberof command_request.ScriptInvocationPointers
         * @instance
         */
        Object.defineProperty(ScriptInvocationPointers.prototype, "_argsPointer", {
            get: $util.oneOfGetter($oneOfFields = ["argsPointer"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ScriptInvocationPointers instance using the specified properties.
         * @function create
         * @memberof command_request.ScriptInvocationPointers
         * @static
         * @param {command_request.IScriptInvocationPointers=} [properties] Properties to set
         * @returns {command_request.ScriptInvocationPointers} ScriptInvocationPointers instance
         */
        ScriptInvocationPointers.create = function create(properties) {
            return new ScriptInvocationPointers(properties);
        };

        /**
         * Encodes the specified ScriptInvocationPointers message. Does not implicitly {@link command_request.ScriptInvocationPointers.verify|verify} messages.
         * @function encode
         * @memberof command_request.ScriptInvocationPointers
         * @static
         * @param {command_request.IScriptInvocationPointers} message ScriptInvocationPointers message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScriptInvocationPointers.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.hash);
            if (message.keysPointer != null && Object.hasOwnProperty.call(message, "keysPointer"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.keysPointer);
            if (message.argsPointer != null && Object.hasOwnProperty.call(message, "argsPointer"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.argsPointer);
            return writer;
        };

        /**
         * Encodes the specified ScriptInvocationPointers message, length delimited. Does not implicitly {@link command_request.ScriptInvocationPointers.verify|verify} messages.
         * @function encodeDelimited
         * @memberof command_request.ScriptInvocationPointers
         * @static
         * @param {command_request.IScriptInvocationPointers} message ScriptInvocationPointers message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScriptInvocationPointers.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
        };

        /**
         * Decodes a ScriptInvocationPointers message from the specified reader or buffer.
         * @function decode
         * @memberof command_request.ScriptInvocationPointers
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {command_request.ScriptInvocationPointers} ScriptInvocationPointers
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScriptInvocationPointers.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.command_request.ScriptInvocationPointers();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.hash = reader.string();
                        break;
                    }
                case 2: {
                        message.keysPointer = reader.uint64();
                        break;
                    }
                case 3: {
                        message.argsPointer = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ScriptInvocationPointers message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof command_request.ScriptInvocationPointers
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {command_request.ScriptInvocationPointers} ScriptInvocationPointers
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScriptInvocationPointers.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Gets the default type url for ScriptInvocationPointers
         * @function getTypeUrl
         * @memberof command_request.ScriptInvocationPointers
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ScriptInvocationPointers.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/command_request.ScriptInvocationPointers";
        };

        return ScriptInvocationPointers;
    })();

    command_request.ScriptInvocation = (function() {

        /**
         * Properties of a ScriptInvocation.
         * @memberof command_request
         * @interface IScriptInvocation
         * @property {string|null} [hash] ScriptInvocation hash
         * @property {Array.<Uint8Array>|null} [keys] ScriptInvocation keys
         * @property {Array.<Uint8Array>|null} [args] ScriptInvocation args
         */

        /**
         * Constructs a new ScriptInvocation.
         * @memberof command_request
         * @classdesc Represents a ScriptInvocation.
         * @implements IScriptInvocation
         * @constructor
         * @param {command_request.IScriptInvocation=} [properties] Properties to set
         */
        function ScriptInvocation(properties) {
            this.keys = [];
            this.args = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ScriptInvocation hash.
         * @member {string} hash
         * @memberof command_request.ScriptInvocation
         * @instance
         */
        ScriptInvocation.prototype.hash = "";

        /**
         * ScriptInvocation keys.
         * @member {Array.<Uint8Array>} keys
         * @memberof command_request.ScriptInvocation
         * @instance
         */
        ScriptInvocation.prototype.keys = $util.emptyArray;

        /**
         * ScriptInvocation args.
         * @member {Array.<Uint8Array>} args
         * @memberof command_request.ScriptInvocation
         * @instance
         */
        ScriptInvocation.prototype.args = $util.emptyArray;

        /**
         * Creates a new ScriptInvocation instance using the specified properties.
         * @function create
         * @memberof command_request.ScriptInvocation
         * @static
         * @param {command_request.IScriptInvocation=} [properties] Properties to set
         * @returns {command_request.ScriptInvocation} ScriptInvocation instance
         */
        ScriptInvocation.create = function create(properties) {
            return new ScriptInvocation(properties);
        };

        /**
         * Encodes the specified ScriptInvocation message. Does not implicitly {@link command_request.ScriptInvocation.verify|verify} messages.
         * @function encode
         * @memberof command_request.ScriptInvocation
         * @static
         * @param {command_request.IScriptInvocation} message ScriptInvocation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScriptInvocation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.hash);
            if (message.keys != null && message.keys.length)
                for (var i = 0; i < message.keys.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.keys[i]);
            if (message.args != null && message.args.length)
                for (var i = 0; i < message.args.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.args[i]);
            return writer;
        };

        /**
         * Encodes the specified ScriptInvocation message, length delimited. Does not implicitly {@link command_request.ScriptInvocation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof command_request.ScriptInvocation
         * @static
         * @param {command_request.IScriptInvocation} message ScriptInvocation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScriptInvocation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
        };

        /**
         * Decodes a ScriptInvocation message from the specified reader or buffer.
         * @function decode
         * @memberof command_request.ScriptInvocation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {command_request.ScriptInvocation} ScriptInvocation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScriptInvocation.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.command_request.ScriptInvocation();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.hash = reader.string();
                        break;
                    }
                case 2: {
                        if (!(message.keys && message.keys.length))
                            message.keys = [];
                        message.keys.push(reader.bytes());
                        break;
                    }
                case 3: {
                        if (!(message.args && message.args.length))
                            message.args = [];
                        message.args.push(reader.bytes());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ScriptInvocation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof command_request.ScriptInvocation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {command_request.ScriptInvocation} ScriptInvocation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScriptInvocation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Gets the default type url for ScriptInvocation
         * @function getTypeUrl
         * @memberof command_request.ScriptInvocation
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ScriptInvocation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/command_request.ScriptInvocation";
        };

        return ScriptInvocation;
    })();

    command_request.Batch = (function() {

        /**
         * Properties of a Batch.
         * @memberof command_request
         * @interface IBatch
         * @property {boolean|null} [isAtomic] Batch isAtomic
         * @property {Array.<command_request.ICommand>|null} [commands] Batch commands
         * @property {boolean|null} [raiseOnError] Batch raiseOnError
         * @property {number|null} [timeout] Batch timeout
         * @property {boolean|null} [retryServerError] Batch retryServerError
         * @property {boolean|null} [retryConnectionError] Batch retryConnectionError
         */

        /**
         * Constructs a new Batch.
         * @memberof command_request
         * @classdesc Represents a Batch.
         * @implements IBatch
         * @constructor
         * @param {command_request.IBatch=} [properties] Properties to set
         */
        function Batch(properties) {
            this.commands = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Batch isAtomic.
         * @member {boolean} isAtomic
         * @memberof command_request.Batch
         * @instance
         */
        Batch.prototype.isAtomic = false;

        /**
         * Batch commands.
         * @member {Array.<command_request.ICommand>} commands
         * @memberof command_request.Batch
         * @instance
         */
        Batch.prototype.commands = $util.emptyArray;

        /**
         * Batch raiseOnError.
         * @member {boolean|null|undefined} raiseOnError
         * @memberof command_request.Batch
         * @instance
         */
        Batch.prototype.raiseOnError = null;

        /**
         * Batch timeout.
         * @member {number|null|undefined} timeout
         * @memberof command_request.Batch
         * @instance
         */
        Batch.prototype.timeout = null;

        /**
         * Batch retryServerError.
         * @member {boolean|null|undefined} retryServerError
         * @memberof command_request.Batch
         * @instance
         */
        Batch.prototype.retryServerError = null;

        /**
         * Batch retryConnectionError.
         * @member {boolean|null|undefined} retryConnectionError
         * @memberof command_request.Batch
         * @instance
         */
        Batch.prototype.retryConnectionError = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Batch _raiseOnError.
         * @member {"raiseOnError"|undefined} _raiseOnError
         * @memberof command_request.Batch
         * @instance
         */
        Object.defineProperty(Batch.prototype, "_raiseOnError", {
            get: $util.oneOfGetter($oneOfFields = ["raiseOnError"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Batch _timeout.
         * @member {"timeout"|undefined} _timeout
         * @memberof command_request.Batch
         * @instance
         */
        Object.defineProperty(Batch.prototype, "_timeout", {
            get: $util.oneOfGetter($oneOfFields = ["timeout"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Batch _retryServerError.
         * @member {"retryServerError"|undefined} _retryServerError
         * @memberof command_request.Batch
         * @instance
         */
        Object.defineProperty(Batch.prototype, "_retryServerError", {
            get: $util.oneOfGetter($oneOfFields = ["retryServerError"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Batch _retryConnectionError.
         * @member {"retryConnectionError"|undefined} _retryConnectionError
         * @memberof command_request.Batch
         * @instance
         */
        Object.defineProperty(Batch.prototype, "_retryConnectionError", {
            get: $util.oneOfGetter($oneOfFields = ["retryConnectionError"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Batch instance using the specified properties.
         * @function create
         * @memberof command_request.Batch
         * @static
         * @param {command_request.IBatch=} [properties] Properties to set
         * @returns {command_request.Batch} Batch instance
         */
        Batch.create = function create(properties) {
            return new Batch(properties);
        };

        /**
         * Encodes the specified Batch message. Does not implicitly {@link command_request.Batch.verify|verify} messages.
         * @function encode
         * @memberof command_request.Batch
         * @static
         * @param {command_request.IBatch} message Batch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Batch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isAtomic != null && Object.hasOwnProperty.call(message, "isAtomic"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isAtomic);
            if (message.commands != null && message.commands.length)
                for (var i = 0; i < message.commands.length; ++i)
                    $root.command_request.Command.encode(message.commands[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.raiseOnError != null && Object.hasOwnProperty.call(message, "raiseOnError"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.raiseOnError);
            if (message.timeout != null && Object.hasOwnProperty.call(message, "timeout"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.timeout);
            if (message.retryServerError != null && Object.hasOwnProperty.call(message, "retryServerError"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.retryServerError);
            if (message.retryConnectionError != null && Object.hasOwnProperty.call(message, "retryConnectionError"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.retryConnectionError);
            return writer;
        };

        /**
         * Encodes the specified Batch message, length delimited. Does not implicitly {@link command_request.Batch.verify|verify} messages.
         * @function encodeDelimited
         * @memberof command_request.Batch
         * @static
         * @param {command_request.IBatch} message Batch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Batch.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
        };

        /**
         * Decodes a Batch message from the specified reader or buffer.
         * @function decode
         * @memberof command_request.Batch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {command_request.Batch} Batch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Batch.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.command_request.Batch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.isAtomic = reader.bool();
                        break;
                    }
                case 2: {
                        if (!(message.commands && message.commands.length))
                            message.commands = [];
                        message.commands.push($root.command_request.Command.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        message.raiseOnError = reader.bool();
                        break;
                    }
                case 4: {
                        message.timeout = reader.uint32();
                        break;
                    }
                case 5: {
                        message.retryServerError = reader.bool();
                        break;
                    }
                case 6: {
                        message.retryConnectionError = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Batch message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof command_request.Batch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {command_request.Batch} Batch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Batch.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Gets the default type url for Batch
         * @function getTypeUrl
         * @memberof command_request.Batch
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Batch.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/command_request.Batch";
        };

        return Batch;
    })();

    command_request.ClusterScan = (function() {

        /**
         * Properties of a ClusterScan.
         * @memberof command_request
         * @interface IClusterScan
         * @property {string|null} [cursor] ClusterScan cursor
         * @property {Uint8Array|null} [matchPattern] ClusterScan matchPattern
         * @property {number|Long|null} [count] ClusterScan count
         * @property {string|null} [objectType] ClusterScan objectType
         * @property {boolean|null} [allowNonCoveredSlots] ClusterScan allowNonCoveredSlots
         */

        /**
         * Constructs a new ClusterScan.
         * @memberof command_request
         * @classdesc Represents a ClusterScan.
         * @implements IClusterScan
         * @constructor
         * @param {command_request.IClusterScan=} [properties] Properties to set
         */
        function ClusterScan(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClusterScan cursor.
         * @member {string} cursor
         * @memberof command_request.ClusterScan
         * @instance
         */
        ClusterScan.prototype.cursor = "";

        /**
         * ClusterScan matchPattern.
         * @member {Uint8Array|null|undefined} matchPattern
         * @memberof command_request.ClusterScan
         * @instance
         */
        ClusterScan.prototype.matchPattern = null;

        /**
         * ClusterScan count.
         * @member {number|Long|null|undefined} count
         * @memberof command_request.ClusterScan
         * @instance
         */
        ClusterScan.prototype.count = null;

        /**
         * ClusterScan objectType.
         * @member {string|null|undefined} objectType
         * @memberof command_request.ClusterScan
         * @instance
         */
        ClusterScan.prototype.objectType = null;

        /**
         * ClusterScan allowNonCoveredSlots.
         * @member {boolean} allowNonCoveredSlots
         * @memberof command_request.ClusterScan
         * @instance
         */
        ClusterScan.prototype.allowNonCoveredSlots = false;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * ClusterScan _matchPattern.
         * @member {"matchPattern"|undefined} _matchPattern
         * @memberof command_request.ClusterScan
         * @instance
         */
        Object.defineProperty(ClusterScan.prototype, "_matchPattern", {
            get: $util.oneOfGetter($oneOfFields = ["matchPattern"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * ClusterScan _count.
         * @member {"count"|undefined} _count
         * @memberof command_request.ClusterScan
         * @instance
         */
        Object.defineProperty(ClusterScan.prototype, "_count", {
            get: $util.oneOfGetter($oneOfFields = ["count"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * ClusterScan _objectType.
         * @member {"objectType"|undefined} _objectType
         * @memberof command_request.ClusterScan
         * @instance
         */
        Object.defineProperty(ClusterScan.prototype, "_objectType", {
            get: $util.oneOfGetter($oneOfFields = ["objectType"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ClusterScan instance using the specified properties.
         * @function create
         * @memberof command_request.ClusterScan
         * @static
         * @param {command_request.IClusterScan=} [properties] Properties to set
         * @returns {command_request.ClusterScan} ClusterScan instance
         */
        ClusterScan.create = function create(properties) {
            return new ClusterScan(properties);
        };

        /**
         * Encodes the specified ClusterScan message. Does not implicitly {@link command_request.ClusterScan.verify|verify} messages.
         * @function encode
         * @memberof command_request.ClusterScan
         * @static
         * @param {command_request.IClusterScan} message ClusterScan message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClusterScan.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cursor != null && Object.hasOwnProperty.call(message, "cursor"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.cursor);
            if (message.matchPattern != null && Object.hasOwnProperty.call(message, "matchPattern"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.matchPattern);
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.count);
            if (message.objectType != null && Object.hasOwnProperty.call(message, "objectType"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.objectType);
            if (message.allowNonCoveredSlots != null && Object.hasOwnProperty.call(message, "allowNonCoveredSlots"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.allowNonCoveredSlots);
            return writer;
        };

        /**
         * Encodes the specified ClusterScan message, length delimited. Does not implicitly {@link command_request.ClusterScan.verify|verify} messages.
         * @function encodeDelimited
         * @memberof command_request.ClusterScan
         * @static
         * @param {command_request.IClusterScan} message ClusterScan message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClusterScan.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
        };

        /**
         * Decodes a ClusterScan message from the specified reader or buffer.
         * @function decode
         * @memberof command_request.ClusterScan
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {command_request.ClusterScan} ClusterScan
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClusterScan.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.command_request.ClusterScan();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.cursor = reader.string();
                        break;
                    }
                case 2: {
                        message.matchPattern = reader.bytes();
                        break;
                    }
                case 3: {
                        message.count = reader.int64();
                        break;
                    }
                case 4: {
                        message.objectType = reader.string();
                        break;
                    }
                case 5: {
                        message.allowNonCoveredSlots = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClusterScan message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof command_request.ClusterScan
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {command_request.ClusterScan} ClusterScan
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClusterScan.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Gets the default type url for ClusterScan
         * @function getTypeUrl
         * @memberof command_request.ClusterScan
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClusterScan.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/command_request.ClusterScan";
        };

        return ClusterScan;
    })();

    command_request.UpdateConnectionPassword = (function() {

        /**
         * Properties of an UpdateConnectionPassword.
         * @memberof command_request
         * @interface IUpdateConnectionPassword
         * @property {string|null} [password] UpdateConnectionPassword password
         * @property {boolean|null} [immediateAuth] UpdateConnectionPassword immediateAuth
         */

        /**
         * Constructs a new UpdateConnectionPassword.
         * @memberof command_request
         * @classdesc Represents an UpdateConnectionPassword.
         * @implements IUpdateConnectionPassword
         * @constructor
         * @param {command_request.IUpdateConnectionPassword=} [properties] Properties to set
         */
        function UpdateConnectionPassword(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateConnectionPassword password.
         * @member {string|null|undefined} password
         * @memberof command_request.UpdateConnectionPassword
         * @instance
         */
        UpdateConnectionPassword.prototype.password = null;

        /**
         * UpdateConnectionPassword immediateAuth.
         * @member {boolean} immediateAuth
         * @memberof command_request.UpdateConnectionPassword
         * @instance
         */
        UpdateConnectionPassword.prototype.immediateAuth = false;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * UpdateConnectionPassword _password.
         * @member {"password"|undefined} _password
         * @memberof command_request.UpdateConnectionPassword
         * @instance
         */
        Object.defineProperty(UpdateConnectionPassword.prototype, "_password", {
            get: $util.oneOfGetter($oneOfFields = ["password"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new UpdateConnectionPassword instance using the specified properties.
         * @function create
         * @memberof command_request.UpdateConnectionPassword
         * @static
         * @param {command_request.IUpdateConnectionPassword=} [properties] Properties to set
         * @returns {command_request.UpdateConnectionPassword} UpdateConnectionPassword instance
         */
        UpdateConnectionPassword.create = function create(properties) {
            return new UpdateConnectionPassword(properties);
        };

        /**
         * Encodes the specified UpdateConnectionPassword message. Does not implicitly {@link command_request.UpdateConnectionPassword.verify|verify} messages.
         * @function encode
         * @memberof command_request.UpdateConnectionPassword
         * @static
         * @param {command_request.IUpdateConnectionPassword} message UpdateConnectionPassword message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateConnectionPassword.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.password);
            if (message.immediateAuth != null && Object.hasOwnProperty.call(message, "immediateAuth"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.immediateAuth);
            return writer;
        };

        /**
         * Encodes the specified UpdateConnectionPassword message, length delimited. Does not implicitly {@link command_request.UpdateConnectionPassword.verify|verify} messages.
         * @function encodeDelimited
         * @memberof command_request.UpdateConnectionPassword
         * @static
         * @param {command_request.IUpdateConnectionPassword} message UpdateConnectionPassword message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateConnectionPassword.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
        };

        /**
         * Decodes an UpdateConnectionPassword message from the specified reader or buffer.
         * @function decode
         * @memberof command_request.UpdateConnectionPassword
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {command_request.UpdateConnectionPassword} UpdateConnectionPassword
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateConnectionPassword.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.command_request.UpdateConnectionPassword();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.password = reader.string();
                        break;
                    }
                case 2: {
                        message.immediateAuth = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateConnectionPassword message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof command_request.UpdateConnectionPassword
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {command_request.UpdateConnectionPassword} UpdateConnectionPassword
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateConnectionPassword.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Gets the default type url for UpdateConnectionPassword
         * @function getTypeUrl
         * @memberof command_request.UpdateConnectionPassword
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UpdateConnectionPassword.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/command_request.UpdateConnectionPassword";
        };

        return UpdateConnectionPassword;
    })();

    command_request.RefreshIamToken = (function() {

        /**
         * Properties of a RefreshIamToken.
         * @memberof command_request
         * @interface IRefreshIamToken
         */

        /**
         * Constructs a new RefreshIamToken.
         * @memberof command_request
         * @classdesc Represents a RefreshIamToken.
         * @implements IRefreshIamToken
         * @constructor
         * @param {command_request.IRefreshIamToken=} [properties] Properties to set
         */
        function RefreshIamToken(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RefreshIamToken instance using the specified properties.
         * @function create
         * @memberof command_request.RefreshIamToken
         * @static
         * @param {command_request.IRefreshIamToken=} [properties] Properties to set
         * @returns {command_request.RefreshIamToken} RefreshIamToken instance
         */
        RefreshIamToken.create = function create(properties) {
            return new RefreshIamToken(properties);
        };

        /**
         * Encodes the specified RefreshIamToken message. Does not implicitly {@link command_request.RefreshIamToken.verify|verify} messages.
         * @function encode
         * @memberof command_request.RefreshIamToken
         * @static
         * @param {command_request.IRefreshIamToken} message RefreshIamToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RefreshIamToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RefreshIamToken message, length delimited. Does not implicitly {@link command_request.RefreshIamToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof command_request.RefreshIamToken
         * @static
         * @param {command_request.IRefreshIamToken} message RefreshIamToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RefreshIamToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
        };

        /**
         * Decodes a RefreshIamToken message from the specified reader or buffer.
         * @function decode
         * @memberof command_request.RefreshIamToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {command_request.RefreshIamToken} RefreshIamToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RefreshIamToken.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.command_request.RefreshIamToken();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RefreshIamToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof command_request.RefreshIamToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {command_request.RefreshIamToken} RefreshIamToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RefreshIamToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Gets the default type url for RefreshIamToken
         * @function getTypeUrl
         * @memberof command_request.RefreshIamToken
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RefreshIamToken.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/command_request.RefreshIamToken";
        };

        return RefreshIamToken;
    })();

    command_request.CommandRequest = (function() {

        /**
         * Properties of a CommandRequest.
         * @memberof command_request
         * @interface ICommandRequest
         * @property {number|null} [callbackIdx] CommandRequest callbackIdx
         * @property {command_request.ICommand|null} [singleCommand] CommandRequest singleCommand
         * @property {command_request.IBatch|null} [batch] CommandRequest batch
         * @property {command_request.IScriptInvocation|null} [scriptInvocation] CommandRequest scriptInvocation
         * @property {command_request.IScriptInvocationPointers|null} [scriptInvocationPointers] CommandRequest scriptInvocationPointers
         * @property {command_request.IClusterScan|null} [clusterScan] CommandRequest clusterScan
         * @property {command_request.IUpdateConnectionPassword|null} [updateConnectionPassword] CommandRequest updateConnectionPassword
         * @property {command_request.IRefreshIamToken|null} [refreshIamToken] CommandRequest refreshIamToken
         * @property {command_request.IRoutes|null} [route] CommandRequest route
         * @property {number|Long|null} [rootSpanPtr] CommandRequest rootSpanPtr
         */

        /**
         * Constructs a new CommandRequest.
         * @memberof command_request
         * @classdesc Represents a CommandRequest.
         * @implements ICommandRequest
         * @constructor
         * @param {command_request.ICommandRequest=} [properties] Properties to set
         */
        function CommandRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommandRequest callbackIdx.
         * @member {number} callbackIdx
         * @memberof command_request.CommandRequest
         * @instance
         */
        CommandRequest.prototype.callbackIdx = 0;

        /**
         * CommandRequest singleCommand.
         * @member {command_request.ICommand|null|undefined} singleCommand
         * @memberof command_request.CommandRequest
         * @instance
         */
        CommandRequest.prototype.singleCommand = null;

        /**
         * CommandRequest batch.
         * @member {command_request.IBatch|null|undefined} batch
         * @memberof command_request.CommandRequest
         * @instance
         */
        CommandRequest.prototype.batch = null;

        /**
         * CommandRequest scriptInvocation.
         * @member {command_request.IScriptInvocation|null|undefined} scriptInvocation
         * @memberof command_request.CommandRequest
         * @instance
         */
        CommandRequest.prototype.scriptInvocation = null;

        /**
         * CommandRequest scriptInvocationPointers.
         * @member {command_request.IScriptInvocationPointers|null|undefined} scriptInvocationPointers
         * @memberof command_request.CommandRequest
         * @instance
         */
        CommandRequest.prototype.scriptInvocationPointers = null;

        /**
         * CommandRequest clusterScan.
         * @member {command_request.IClusterScan|null|undefined} clusterScan
         * @memberof command_request.CommandRequest
         * @instance
         */
        CommandRequest.prototype.clusterScan = null;

        /**
         * CommandRequest updateConnectionPassword.
         * @member {command_request.IUpdateConnectionPassword|null|undefined} updateConnectionPassword
         * @memberof command_request.CommandRequest
         * @instance
         */
        CommandRequest.prototype.updateConnectionPassword = null;

        /**
         * CommandRequest refreshIamToken.
         * @member {command_request.IRefreshIamToken|null|undefined} refreshIamToken
         * @memberof command_request.CommandRequest
         * @instance
         */
        CommandRequest.prototype.refreshIamToken = null;

        /**
         * CommandRequest route.
         * @member {command_request.IRoutes|null|undefined} route
         * @memberof command_request.CommandRequest
         * @instance
         */
        CommandRequest.prototype.route = null;

        /**
         * CommandRequest rootSpanPtr.
         * @member {number|Long|null|undefined} rootSpanPtr
         * @memberof command_request.CommandRequest
         * @instance
         */
        CommandRequest.prototype.rootSpanPtr = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * CommandRequest command.
         * @member {"singleCommand"|"batch"|"scriptInvocation"|"scriptInvocationPointers"|"clusterScan"|"updateConnectionPassword"|"refreshIamToken"|undefined} command
         * @memberof command_request.CommandRequest
         * @instance
         */
        Object.defineProperty(CommandRequest.prototype, "command", {
            get: $util.oneOfGetter($oneOfFields = ["singleCommand", "batch", "scriptInvocation", "scriptInvocationPointers", "clusterScan", "updateConnectionPassword", "refreshIamToken"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * CommandRequest _rootSpanPtr.
         * @member {"rootSpanPtr"|undefined} _rootSpanPtr
         * @memberof command_request.CommandRequest
         * @instance
         */
        Object.defineProperty(CommandRequest.prototype, "_rootSpanPtr", {
            get: $util.oneOfGetter($oneOfFields = ["rootSpanPtr"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new CommandRequest instance using the specified properties.
         * @function create
         * @memberof command_request.CommandRequest
         * @static
         * @param {command_request.ICommandRequest=} [properties] Properties to set
         * @returns {command_request.CommandRequest} CommandRequest instance
         */
        CommandRequest.create = function create(properties) {
            return new CommandRequest(properties);
        };

        /**
         * Encodes the specified CommandRequest message. Does not implicitly {@link command_request.CommandRequest.verify|verify} messages.
         * @function encode
         * @memberof command_request.CommandRequest
         * @static
         * @param {command_request.ICommandRequest} message CommandRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommandRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callbackIdx != null && Object.hasOwnProperty.call(message, "callbackIdx"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.callbackIdx);
            if (message.singleCommand != null && Object.hasOwnProperty.call(message, "singleCommand"))
                $root.command_request.Command.encode(message.singleCommand, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.batch != null && Object.hasOwnProperty.call(message, "batch"))
                $root.command_request.Batch.encode(message.batch, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.scriptInvocation != null && Object.hasOwnProperty.call(message, "scriptInvocation"))
                $root.command_request.ScriptInvocation.encode(message.scriptInvocation, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.scriptInvocationPointers != null && Object.hasOwnProperty.call(message, "scriptInvocationPointers"))
                $root.command_request.ScriptInvocationPointers.encode(message.scriptInvocationPointers, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.clusterScan != null && Object.hasOwnProperty.call(message, "clusterScan"))
                $root.command_request.ClusterScan.encode(message.clusterScan, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.updateConnectionPassword != null && Object.hasOwnProperty.call(message, "updateConnectionPassword"))
                $root.command_request.UpdateConnectionPassword.encode(message.updateConnectionPassword, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.refreshIamToken != null && Object.hasOwnProperty.call(message, "refreshIamToken"))
                $root.command_request.RefreshIamToken.encode(message.refreshIamToken, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.route != null && Object.hasOwnProperty.call(message, "route"))
                $root.command_request.Routes.encode(message.route, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.rootSpanPtr != null && Object.hasOwnProperty.call(message, "rootSpanPtr"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.rootSpanPtr);
            return writer;
        };

        /**
         * Encodes the specified CommandRequest message, length delimited. Does not implicitly {@link command_request.CommandRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof command_request.CommandRequest
         * @static
         * @param {command_request.ICommandRequest} message CommandRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommandRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
        };

        /**
         * Decodes a CommandRequest message from the specified reader or buffer.
         * @function decode
         * @memberof command_request.CommandRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {command_request.CommandRequest} CommandRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommandRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.command_request.CommandRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.callbackIdx = reader.uint32();
                        break;
                    }
                case 2: {
                        message.singleCommand = $root.command_request.Command.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.batch = $root.command_request.Batch.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.scriptInvocation = $root.command_request.ScriptInvocation.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.scriptInvocationPointers = $root.command_request.ScriptInvocationPointers.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.clusterScan = $root.command_request.ClusterScan.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.updateConnectionPassword = $root.command_request.UpdateConnectionPassword.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.refreshIamToken = $root.command_request.RefreshIamToken.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.route = $root.command_request.Routes.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.rootSpanPtr = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommandRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof command_request.CommandRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {command_request.CommandRequest} CommandRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommandRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Gets the default type url for CommandRequest
         * @function getTypeUrl
         * @memberof command_request.CommandRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CommandRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/command_request.CommandRequest";
        };

        return CommandRequest;
    })();

    return command_request;
})();

$root.connection_request = (function() {

    /**
     * Namespace connection_request.
     * @exports connection_request
     * @namespace
     */
    var connection_request = {};

    connection_request.NodeAddress = (function() {

        /**
         * Properties of a NodeAddress.
         * @memberof connection_request
         * @interface INodeAddress
         * @property {string|null} [host] NodeAddress host
         * @property {number|null} [port] NodeAddress port
         */

        /**
         * Constructs a new NodeAddress.
         * @memberof connection_request
         * @classdesc Represents a NodeAddress.
         * @implements INodeAddress
         * @constructor
         * @param {connection_request.INodeAddress=} [properties] Properties to set
         */
        function NodeAddress(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeAddress host.
         * @member {string} host
         * @memberof connection_request.NodeAddress
         * @instance
         */
        NodeAddress.prototype.host = "";

        /**
         * NodeAddress port.
         * @member {number} port
         * @memberof connection_request.NodeAddress
         * @instance
         */
        NodeAddress.prototype.port = 0;

        /**
         * Creates a new NodeAddress instance using the specified properties.
         * @function create
         * @memberof connection_request.NodeAddress
         * @static
         * @param {connection_request.INodeAddress=} [properties] Properties to set
         * @returns {connection_request.NodeAddress} NodeAddress instance
         */
        NodeAddress.create = function create(properties) {
            return new NodeAddress(properties);
        };

        /**
         * Encodes the specified NodeAddress message. Does not implicitly {@link connection_request.NodeAddress.verify|verify} messages.
         * @function encode
         * @memberof connection_request.NodeAddress
         * @static
         * @param {connection_request.INodeAddress} message NodeAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeAddress.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.host != null && Object.hasOwnProperty.call(message, "host"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.host);
            if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.port);
            return writer;
        };

        /**
         * Encodes the specified NodeAddress message, length delimited. Does not implicitly {@link connection_request.NodeAddress.verify|verify} messages.
         * @function encodeDelimited
         * @memberof connection_request.NodeAddress
         * @static
         * @param {connection_request.INodeAddress} message NodeAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeAddress.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
        };

        /**
         * Decodes a NodeAddress message from the specified reader or buffer.
         * @function decode
         * @memberof connection_request.NodeAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {connection_request.NodeAddress} NodeAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeAddress.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.connection_request.NodeAddress();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.host = reader.string();
                        break;
                    }
                case 2: {
                        message.port = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeAddress message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof connection_request.NodeAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {connection_request.NodeAddress} NodeAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeAddress.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Gets the default type url for NodeAddress
         * @function getTypeUrl
         * @memberof connection_request.NodeAddress
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NodeAddress.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/connection_request.NodeAddress";
        };

        return NodeAddress;
    })();

    /**
     * ReadFrom enum.
     * @name connection_request.ReadFrom
     * @enum {number}
     * @property {number} Primary=0 Primary value
     * @property {number} PreferReplica=1 PreferReplica value
     * @property {number} LowestLatency=2 LowestLatency value
     * @property {number} AZAffinity=3 AZAffinity value
     * @property {number} AZAffinityReplicasAndPrimary=4 AZAffinityReplicasAndPrimary value
     */
    connection_request.ReadFrom = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Primary"] = 0;
        values[valuesById[1] = "PreferReplica"] = 1;
        values[valuesById[2] = "LowestLatency"] = 2;
        values[valuesById[3] = "AZAffinity"] = 3;
        values[valuesById[4] = "AZAffinityReplicasAndPrimary"] = 4;
        return values;
    })();

    /**
     * TlsMode enum.
     * @name connection_request.TlsMode
     * @enum {number}
     * @property {number} NoTls=0 NoTls value
     * @property {number} SecureTls=1 SecureTls value
     * @property {number} InsecureTls=2 InsecureTls value
     */
    connection_request.TlsMode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NoTls"] = 0;
        values[valuesById[1] = "SecureTls"] = 1;
        values[valuesById[2] = "InsecureTls"] = 2;
        return values;
    })();

    connection_request.AuthenticationInfo = (function() {

        /**
         * Properties of an AuthenticationInfo.
         * @memberof connection_request
         * @interface IAuthenticationInfo
         * @property {string|null} [password] AuthenticationInfo password
         * @property {string|null} [username] AuthenticationInfo username
         * @property {connection_request.IIamCredentials|null} [iamCredentials] AuthenticationInfo iamCredentials
         */

        /**
         * Constructs a new AuthenticationInfo.
         * @memberof connection_request
         * @classdesc Represents an AuthenticationInfo.
         * @implements IAuthenticationInfo
         * @constructor
         * @param {connection_request.IAuthenticationInfo=} [properties] Properties to set
         */
        function AuthenticationInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AuthenticationInfo password.
         * @member {string} password
         * @memberof connection_request.AuthenticationInfo
         * @instance
         */
        AuthenticationInfo.prototype.password = "";

        /**
         * AuthenticationInfo username.
         * @member {string} username
         * @memberof connection_request.AuthenticationInfo
         * @instance
         */
        AuthenticationInfo.prototype.username = "";

        /**
         * AuthenticationInfo iamCredentials.
         * @member {connection_request.IIamCredentials|null|undefined} iamCredentials
         * @memberof connection_request.AuthenticationInfo
         * @instance
         */
        AuthenticationInfo.prototype.iamCredentials = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * AuthenticationInfo _iamCredentials.
         * @member {"iamCredentials"|undefined} _iamCredentials
         * @memberof connection_request.AuthenticationInfo
         * @instance
         */
        Object.defineProperty(AuthenticationInfo.prototype, "_iamCredentials", {
            get: $util.oneOfGetter($oneOfFields = ["iamCredentials"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new AuthenticationInfo instance using the specified properties.
         * @function create
         * @memberof connection_request.AuthenticationInfo
         * @static
         * @param {connection_request.IAuthenticationInfo=} [properties] Properties to set
         * @returns {connection_request.AuthenticationInfo} AuthenticationInfo instance
         */
        AuthenticationInfo.create = function create(properties) {
            return new AuthenticationInfo(properties);
        };

        /**
         * Encodes the specified AuthenticationInfo message. Does not implicitly {@link connection_request.AuthenticationInfo.verify|verify} messages.
         * @function encode
         * @memberof connection_request.AuthenticationInfo
         * @static
         * @param {connection_request.IAuthenticationInfo} message AuthenticationInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthenticationInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.password);
            if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
            if (message.iamCredentials != null && Object.hasOwnProperty.call(message, "iamCredentials"))
                $root.connection_request.IamCredentials.encode(message.iamCredentials, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AuthenticationInfo message, length delimited. Does not implicitly {@link connection_request.AuthenticationInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof connection_request.AuthenticationInfo
         * @static
         * @param {connection_request.IAuthenticationInfo} message AuthenticationInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthenticationInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
        };

        /**
         * Decodes an AuthenticationInfo message from the specified reader or buffer.
         * @function decode
         * @memberof connection_request.AuthenticationInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {connection_request.AuthenticationInfo} AuthenticationInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthenticationInfo.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.connection_request.AuthenticationInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.password = reader.string();
                        break;
                    }
                case 2: {
                        message.username = reader.string();
                        break;
                    }
                case 3: {
                        message.iamCredentials = $root.connection_request.IamCredentials.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AuthenticationInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof connection_request.AuthenticationInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {connection_request.AuthenticationInfo} AuthenticationInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthenticationInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Gets the default type url for AuthenticationInfo
         * @function getTypeUrl
         * @memberof connection_request.AuthenticationInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AuthenticationInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/connection_request.AuthenticationInfo";
        };

        return AuthenticationInfo;
    })();

    /**
     * ServiceType enum.
     * @name connection_request.ServiceType
     * @enum {number}
     * @property {number} ELASTICACHE=0 ELASTICACHE value
     * @property {number} MEMORYDB=1 MEMORYDB value
     */
    connection_request.ServiceType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ELASTICACHE"] = 0;
        values[valuesById[1] = "MEMORYDB"] = 1;
        return values;
    })();

    connection_request.IamCredentials = (function() {

        /**
         * Properties of an IamCredentials.
         * @memberof connection_request
         * @interface IIamCredentials
         * @property {string|null} [clusterName] IamCredentials clusterName
         * @property {string|null} [region] IamCredentials region
         * @property {connection_request.ServiceType|null} [serviceType] IamCredentials serviceType
         * @property {number|null} [refreshIntervalSeconds] IamCredentials refreshIntervalSeconds
         */

        /**
         * Constructs a new IamCredentials.
         * @memberof connection_request
         * @classdesc Represents an IamCredentials.
         * @implements IIamCredentials
         * @constructor
         * @param {connection_request.IIamCredentials=} [properties] Properties to set
         */
        function IamCredentials(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IamCredentials clusterName.
         * @member {string} clusterName
         * @memberof connection_request.IamCredentials
         * @instance
         */
        IamCredentials.prototype.clusterName = "";

        /**
         * IamCredentials region.
         * @member {string} region
         * @memberof connection_request.IamCredentials
         * @instance
         */
        IamCredentials.prototype.region = "";

        /**
         * IamCredentials serviceType.
         * @member {connection_request.ServiceType} serviceType
         * @memberof connection_request.IamCredentials
         * @instance
         */
        IamCredentials.prototype.serviceType = 0;

        /**
         * IamCredentials refreshIntervalSeconds.
         * @member {number|null|undefined} refreshIntervalSeconds
         * @memberof connection_request.IamCredentials
         * @instance
         */
        IamCredentials.prototype.refreshIntervalSeconds = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * IamCredentials _refreshIntervalSeconds.
         * @member {"refreshIntervalSeconds"|undefined} _refreshIntervalSeconds
         * @memberof connection_request.IamCredentials
         * @instance
         */
        Object.defineProperty(IamCredentials.prototype, "_refreshIntervalSeconds", {
            get: $util.oneOfGetter($oneOfFields = ["refreshIntervalSeconds"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new IamCredentials instance using the specified properties.
         * @function create
         * @memberof connection_request.IamCredentials
         * @static
         * @param {connection_request.IIamCredentials=} [properties] Properties to set
         * @returns {connection_request.IamCredentials} IamCredentials instance
         */
        IamCredentials.create = function create(properties) {
            return new IamCredentials(properties);
        };

        /**
         * Encodes the specified IamCredentials message. Does not implicitly {@link connection_request.IamCredentials.verify|verify} messages.
         * @function encode
         * @memberof connection_request.IamCredentials
         * @static
         * @param {connection_request.IIamCredentials} message IamCredentials message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IamCredentials.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.clusterName != null && Object.hasOwnProperty.call(message, "clusterName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.clusterName);
            if (message.region != null && Object.hasOwnProperty.call(message, "region"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.region);
            if (message.serviceType != null && Object.hasOwnProperty.call(message, "serviceType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.serviceType);
            if (message.refreshIntervalSeconds != null && Object.hasOwnProperty.call(message, "refreshIntervalSeconds"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.refreshIntervalSeconds);
            return writer;
        };

        /**
         * Encodes the specified IamCredentials message, length delimited. Does not implicitly {@link connection_request.IamCredentials.verify|verify} messages.
         * @function encodeDelimited
         * @memberof connection_request.IamCredentials
         * @static
         * @param {connection_request.IIamCredentials} message IamCredentials message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IamCredentials.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
        };

        /**
         * Decodes an IamCredentials message from the specified reader or buffer.
         * @function decode
         * @memberof connection_request.IamCredentials
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {connection_request.IamCredentials} IamCredentials
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IamCredentials.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.connection_request.IamCredentials();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.clusterName = reader.string();
                        break;
                    }
                case 2: {
                        message.region = reader.string();
                        break;
                    }
                case 3: {
                        message.serviceType = reader.int32();
                        break;
                    }
                case 4: {
                        message.refreshIntervalSeconds = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IamCredentials message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof connection_request.IamCredentials
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {connection_request.IamCredentials} IamCredentials
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IamCredentials.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Gets the default type url for IamCredentials
         * @function getTypeUrl
         * @memberof connection_request.IamCredentials
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        IamCredentials.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/connection_request.IamCredentials";
        };

        return IamCredentials;
    })();

    /**
     * ProtocolVersion enum.
     * @name connection_request.ProtocolVersion
     * @enum {number}
     * @property {number} RESP3=0 RESP3 value
     * @property {number} RESP2=1 RESP2 value
     */
    connection_request.ProtocolVersion = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "RESP3"] = 0;
        values[valuesById[1] = "RESP2"] = 1;
        return values;
    })();

    connection_request.PeriodicChecksManualInterval = (function() {

        /**
         * Properties of a PeriodicChecksManualInterval.
         * @memberof connection_request
         * @interface IPeriodicChecksManualInterval
         * @property {number|null} [durationInSec] PeriodicChecksManualInterval durationInSec
         */

        /**
         * Constructs a new PeriodicChecksManualInterval.
         * @memberof connection_request
         * @classdesc Represents a PeriodicChecksManualInterval.
         * @implements IPeriodicChecksManualInterval
         * @constructor
         * @param {connection_request.IPeriodicChecksManualInterval=} [properties] Properties to set
         */
        function PeriodicChecksManualInterval(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PeriodicChecksManualInterval durationInSec.
         * @member {number} durationInSec
         * @memberof connection_request.PeriodicChecksManualInterval
         * @instance
         */
        PeriodicChecksManualInterval.prototype.durationInSec = 0;

        /**
         * Creates a new PeriodicChecksManualInterval instance using the specified properties.
         * @function create
         * @memberof connection_request.PeriodicChecksManualInterval
         * @static
         * @param {connection_request.IPeriodicChecksManualInterval=} [properties] Properties to set
         * @returns {connection_request.PeriodicChecksManualInterval} PeriodicChecksManualInterval instance
         */
        PeriodicChecksManualInterval.create = function create(properties) {
            return new PeriodicChecksManualInterval(properties);
        };

        /**
         * Encodes the specified PeriodicChecksManualInterval message. Does not implicitly {@link connection_request.PeriodicChecksManualInterval.verify|verify} messages.
         * @function encode
         * @memberof connection_request.PeriodicChecksManualInterval
         * @static
         * @param {connection_request.IPeriodicChecksManualInterval} message PeriodicChecksManualInterval message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PeriodicChecksManualInterval.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.durationInSec != null && Object.hasOwnProperty.call(message, "durationInSec"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.durationInSec);
            return writer;
        };

        /**
         * Encodes the specified PeriodicChecksManualInterval message, length delimited. Does not implicitly {@link connection_request.PeriodicChecksManualInterval.verify|verify} messages.
         * @function encodeDelimited
         * @memberof connection_request.PeriodicChecksManualInterval
         * @static
         * @param {connection_request.IPeriodicChecksManualInterval} message PeriodicChecksManualInterval message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PeriodicChecksManualInterval.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
        };

        /**
         * Decodes a PeriodicChecksManualInterval message from the specified reader or buffer.
         * @function decode
         * @memberof connection_request.PeriodicChecksManualInterval
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {connection_request.PeriodicChecksManualInterval} PeriodicChecksManualInterval
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PeriodicChecksManualInterval.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.connection_request.PeriodicChecksManualInterval();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.durationInSec = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PeriodicChecksManualInterval message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof connection_request.PeriodicChecksManualInterval
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {connection_request.PeriodicChecksManualInterval} PeriodicChecksManualInterval
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PeriodicChecksManualInterval.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Gets the default type url for PeriodicChecksManualInterval
         * @function getTypeUrl
         * @memberof connection_request.PeriodicChecksManualInterval
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PeriodicChecksManualInterval.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/connection_request.PeriodicChecksManualInterval";
        };

        return PeriodicChecksManualInterval;
    })();

    connection_request.PeriodicChecksDisabled = (function() {

        /**
         * Properties of a PeriodicChecksDisabled.
         * @memberof connection_request
         * @interface IPeriodicChecksDisabled
         */

        /**
         * Constructs a new PeriodicChecksDisabled.
         * @memberof connection_request
         * @classdesc Represents a PeriodicChecksDisabled.
         * @implements IPeriodicChecksDisabled
         * @constructor
         * @param {connection_request.IPeriodicChecksDisabled=} [properties] Properties to set
         */
        function PeriodicChecksDisabled(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PeriodicChecksDisabled instance using the specified properties.
         * @function create
         * @memberof connection_request.PeriodicChecksDisabled
         * @static
         * @param {connection_request.IPeriodicChecksDisabled=} [properties] Properties to set
         * @returns {connection_request.PeriodicChecksDisabled} PeriodicChecksDisabled instance
         */
        PeriodicChecksDisabled.create = function create(properties) {
            return new PeriodicChecksDisabled(properties);
        };

        /**
         * Encodes the specified PeriodicChecksDisabled message. Does not implicitly {@link connection_request.PeriodicChecksDisabled.verify|verify} messages.
         * @function encode
         * @memberof connection_request.PeriodicChecksDisabled
         * @static
         * @param {connection_request.IPeriodicChecksDisabled} message PeriodicChecksDisabled message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PeriodicChecksDisabled.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PeriodicChecksDisabled message, length delimited. Does not implicitly {@link connection_request.PeriodicChecksDisabled.verify|verify} messages.
         * @function encodeDelimited
         * @memberof connection_request.PeriodicChecksDisabled
         * @static
         * @param {connection_request.IPeriodicChecksDisabled} message PeriodicChecksDisabled message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PeriodicChecksDisabled.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
        };

        /**
         * Decodes a PeriodicChecksDisabled message from the specified reader or buffer.
         * @function decode
         * @memberof connection_request.PeriodicChecksDisabled
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {connection_request.PeriodicChecksDisabled} PeriodicChecksDisabled
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PeriodicChecksDisabled.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.connection_request.PeriodicChecksDisabled();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PeriodicChecksDisabled message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof connection_request.PeriodicChecksDisabled
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {connection_request.PeriodicChecksDisabled} PeriodicChecksDisabled
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PeriodicChecksDisabled.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Gets the default type url for PeriodicChecksDisabled
         * @function getTypeUrl
         * @memberof connection_request.PeriodicChecksDisabled
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PeriodicChecksDisabled.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/connection_request.PeriodicChecksDisabled";
        };

        return PeriodicChecksDisabled;
    })();

    /**
     * PubSubChannelType enum.
     * @name connection_request.PubSubChannelType
     * @enum {number}
     * @property {number} Exact=0 Exact value
     * @property {number} Pattern=1 Pattern value
     * @property {number} Sharded=2 Sharded value
     */
    connection_request.PubSubChannelType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Exact"] = 0;
        values[valuesById[1] = "Pattern"] = 1;
        values[valuesById[2] = "Sharded"] = 2;
        return values;
    })();

    connection_request.PubSubChannelsOrPatterns = (function() {

        /**
         * Properties of a PubSubChannelsOrPatterns.
         * @memberof connection_request
         * @interface IPubSubChannelsOrPatterns
         * @property {Array.<Uint8Array>|null} [channelsOrPatterns] PubSubChannelsOrPatterns channelsOrPatterns
         */

        /**
         * Constructs a new PubSubChannelsOrPatterns.
         * @memberof connection_request
         * @classdesc Represents a PubSubChannelsOrPatterns.
         * @implements IPubSubChannelsOrPatterns
         * @constructor
         * @param {connection_request.IPubSubChannelsOrPatterns=} [properties] Properties to set
         */
        function PubSubChannelsOrPatterns(properties) {
            this.channelsOrPatterns = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PubSubChannelsOrPatterns channelsOrPatterns.
         * @member {Array.<Uint8Array>} channelsOrPatterns
         * @memberof connection_request.PubSubChannelsOrPatterns
         * @instance
         */
        PubSubChannelsOrPatterns.prototype.channelsOrPatterns = $util.emptyArray;

        /**
         * Creates a new PubSubChannelsOrPatterns instance using the specified properties.
         * @function create
         * @memberof connection_request.PubSubChannelsOrPatterns
         * @static
         * @param {connection_request.IPubSubChannelsOrPatterns=} [properties] Properties to set
         * @returns {connection_request.PubSubChannelsOrPatterns} PubSubChannelsOrPatterns instance
         */
        PubSubChannelsOrPatterns.create = function create(properties) {
            return new PubSubChannelsOrPatterns(properties);
        };

        /**
         * Encodes the specified PubSubChannelsOrPatterns message. Does not implicitly {@link connection_request.PubSubChannelsOrPatterns.verify|verify} messages.
         * @function encode
         * @memberof connection_request.PubSubChannelsOrPatterns
         * @static
         * @param {connection_request.IPubSubChannelsOrPatterns} message PubSubChannelsOrPatterns message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PubSubChannelsOrPatterns.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelsOrPatterns != null && message.channelsOrPatterns.length)
                for (var i = 0; i < message.channelsOrPatterns.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.channelsOrPatterns[i]);
            return writer;
        };

        /**
         * Encodes the specified PubSubChannelsOrPatterns message, length delimited. Does not implicitly {@link connection_request.PubSubChannelsOrPatterns.verify|verify} messages.
         * @function encodeDelimited
         * @memberof connection_request.PubSubChannelsOrPatterns
         * @static
         * @param {connection_request.IPubSubChannelsOrPatterns} message PubSubChannelsOrPatterns message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PubSubChannelsOrPatterns.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
        };

        /**
         * Decodes a PubSubChannelsOrPatterns message from the specified reader or buffer.
         * @function decode
         * @memberof connection_request.PubSubChannelsOrPatterns
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {connection_request.PubSubChannelsOrPatterns} PubSubChannelsOrPatterns
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PubSubChannelsOrPatterns.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.connection_request.PubSubChannelsOrPatterns();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.channelsOrPatterns && message.channelsOrPatterns.length))
                            message.channelsOrPatterns = [];
                        message.channelsOrPatterns.push(reader.bytes());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PubSubChannelsOrPatterns message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof connection_request.PubSubChannelsOrPatterns
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {connection_request.PubSubChannelsOrPatterns} PubSubChannelsOrPatterns
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PubSubChannelsOrPatterns.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Gets the default type url for PubSubChannelsOrPatterns
         * @function getTypeUrl
         * @memberof connection_request.PubSubChannelsOrPatterns
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PubSubChannelsOrPatterns.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/connection_request.PubSubChannelsOrPatterns";
        };

        return PubSubChannelsOrPatterns;
    })();

    connection_request.PubSubSubscriptions = (function() {

        /**
         * Properties of a PubSubSubscriptions.
         * @memberof connection_request
         * @interface IPubSubSubscriptions
         * @property {Object.<string,connection_request.IPubSubChannelsOrPatterns>|null} [channelsOrPatternsByType] PubSubSubscriptions channelsOrPatternsByType
         */

        /**
         * Constructs a new PubSubSubscriptions.
         * @memberof connection_request
         * @classdesc Represents a PubSubSubscriptions.
         * @implements IPubSubSubscriptions
         * @constructor
         * @param {connection_request.IPubSubSubscriptions=} [properties] Properties to set
         */
        function PubSubSubscriptions(properties) {
            this.channelsOrPatternsByType = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PubSubSubscriptions channelsOrPatternsByType.
         * @member {Object.<string,connection_request.IPubSubChannelsOrPatterns>} channelsOrPatternsByType
         * @memberof connection_request.PubSubSubscriptions
         * @instance
         */
        PubSubSubscriptions.prototype.channelsOrPatternsByType = $util.emptyObject;

        /**
         * Creates a new PubSubSubscriptions instance using the specified properties.
         * @function create
         * @memberof connection_request.PubSubSubscriptions
         * @static
         * @param {connection_request.IPubSubSubscriptions=} [properties] Properties to set
         * @returns {connection_request.PubSubSubscriptions} PubSubSubscriptions instance
         */
        PubSubSubscriptions.create = function create(properties) {
            return new PubSubSubscriptions(properties);
        };

        /**
         * Encodes the specified PubSubSubscriptions message. Does not implicitly {@link connection_request.PubSubSubscriptions.verify|verify} messages.
         * @function encode
         * @memberof connection_request.PubSubSubscriptions
         * @static
         * @param {connection_request.IPubSubSubscriptions} message PubSubSubscriptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PubSubSubscriptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelsOrPatternsByType != null && Object.hasOwnProperty.call(message, "channelsOrPatternsByType"))
                for (var keys = Object.keys(message.channelsOrPatternsByType), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]);
                    $root.connection_request.PubSubChannelsOrPatterns.encode(message.channelsOrPatternsByType[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified PubSubSubscriptions message, length delimited. Does not implicitly {@link connection_request.PubSubSubscriptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof connection_request.PubSubSubscriptions
         * @static
         * @param {connection_request.IPubSubSubscriptions} message PubSubSubscriptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PubSubSubscriptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
        };

        /**
         * Decodes a PubSubSubscriptions message from the specified reader or buffer.
         * @function decode
         * @memberof connection_request.PubSubSubscriptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {connection_request.PubSubSubscriptions} PubSubSubscriptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PubSubSubscriptions.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.connection_request.PubSubSubscriptions(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (message.channelsOrPatternsByType === $util.emptyObject)
                            message.channelsOrPatternsByType = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = 0;
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.uint32();
                                break;
                            case 2:
                                value = $root.connection_request.PubSubChannelsOrPatterns.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.channelsOrPatternsByType[key] = value;
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PubSubSubscriptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof connection_request.PubSubSubscriptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {connection_request.PubSubSubscriptions} PubSubSubscriptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PubSubSubscriptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Gets the default type url for PubSubSubscriptions
         * @function getTypeUrl
         * @memberof connection_request.PubSubSubscriptions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PubSubSubscriptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/connection_request.PubSubSubscriptions";
        };

        return PubSubSubscriptions;
    })();

    connection_request.ConnectionRequest = (function() {

        /**
         * Properties of a ConnectionRequest.
         * @memberof connection_request
         * @interface IConnectionRequest
         * @property {Array.<connection_request.INodeAddress>|null} [addresses] ConnectionRequest addresses
         * @property {connection_request.TlsMode|null} [tlsMode] ConnectionRequest tlsMode
         * @property {boolean|null} [clusterModeEnabled] ConnectionRequest clusterModeEnabled
         * @property {number|null} [requestTimeout] ConnectionRequest requestTimeout
         * @property {connection_request.ReadFrom|null} [readFrom] ConnectionRequest readFrom
         * @property {connection_request.IConnectionRetryStrategy|null} [connectionRetryStrategy] ConnectionRequest connectionRetryStrategy
         * @property {connection_request.IAuthenticationInfo|null} [authenticationInfo] ConnectionRequest authenticationInfo
         * @property {number|null} [databaseId] ConnectionRequest databaseId
         * @property {connection_request.ProtocolVersion|null} [protocol] ConnectionRequest protocol
         * @property {string|null} [clientName] ConnectionRequest clientName
         * @property {connection_request.IPeriodicChecksManualInterval|null} [periodicChecksManualInterval] ConnectionRequest periodicChecksManualInterval
         * @property {connection_request.IPeriodicChecksDisabled|null} [periodicChecksDisabled] ConnectionRequest periodicChecksDisabled
         * @property {connection_request.IPubSubSubscriptions|null} [pubsubSubscriptions] ConnectionRequest pubsubSubscriptions
         * @property {number|null} [inflightRequestsLimit] ConnectionRequest inflightRequestsLimit
         * @property {string|null} [clientAz] ConnectionRequest clientAz
         * @property {number|null} [connectionTimeout] ConnectionRequest connectionTimeout
         * @property {boolean|null} [lazyConnect] ConnectionRequest lazyConnect
         * @property {boolean|null} [refreshTopologyFromInitialNodes] ConnectionRequest refreshTopologyFromInitialNodes
         * @property {string|null} [libName] ConnectionRequest libName
         * @property {Array.<Uint8Array>|null} [rootCerts] ConnectionRequest rootCerts
         */

        /**
         * Constructs a new ConnectionRequest.
         * @memberof connection_request
         * @classdesc Represents a ConnectionRequest.
         * @implements IConnectionRequest
         * @constructor
         * @param {connection_request.IConnectionRequest=} [properties] Properties to set
         */
        function ConnectionRequest(properties) {
            this.addresses = [];
            this.rootCerts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConnectionRequest addresses.
         * @member {Array.<connection_request.INodeAddress>} addresses
         * @memberof connection_request.ConnectionRequest
         * @instance
         */
        ConnectionRequest.prototype.addresses = $util.emptyArray;

        /**
         * ConnectionRequest tlsMode.
         * @member {connection_request.TlsMode} tlsMode
         * @memberof connection_request.ConnectionRequest
         * @instance
         */
        ConnectionRequest.prototype.tlsMode = 0;

        /**
         * ConnectionRequest clusterModeEnabled.
         * @member {boolean} clusterModeEnabled
         * @memberof connection_request.ConnectionRequest
         * @instance
         */
        ConnectionRequest.prototype.clusterModeEnabled = false;

        /**
         * ConnectionRequest requestTimeout.
         * @member {number} requestTimeout
         * @memberof connection_request.ConnectionRequest
         * @instance
         */
        ConnectionRequest.prototype.requestTimeout = 0;

        /**
         * ConnectionRequest readFrom.
         * @member {connection_request.ReadFrom} readFrom
         * @memberof connection_request.ConnectionRequest
         * @instance
         */
        ConnectionRequest.prototype.readFrom = 0;

        /**
         * ConnectionRequest connectionRetryStrategy.
         * @member {connection_request.IConnectionRetryStrategy|null|undefined} connectionRetryStrategy
         * @memberof connection_request.ConnectionRequest
         * @instance
         */
        ConnectionRequest.prototype.connectionRetryStrategy = null;

        /**
         * ConnectionRequest authenticationInfo.
         * @member {connection_request.IAuthenticationInfo|null|undefined} authenticationInfo
         * @memberof connection_request.ConnectionRequest
         * @instance
         */
        ConnectionRequest.prototype.authenticationInfo = null;

        /**
         * ConnectionRequest databaseId.
         * @member {number} databaseId
         * @memberof connection_request.ConnectionRequest
         * @instance
         */
        ConnectionRequest.prototype.databaseId = 0;

        /**
         * ConnectionRequest protocol.
         * @member {connection_request.ProtocolVersion} protocol
         * @memberof connection_request.ConnectionRequest
         * @instance
         */
        ConnectionRequest.prototype.protocol = 0;

        /**
         * ConnectionRequest clientName.
         * @member {string} clientName
         * @memberof connection_request.ConnectionRequest
         * @instance
         */
        ConnectionRequest.prototype.clientName = "";

        /**
         * ConnectionRequest periodicChecksManualInterval.
         * @member {connection_request.IPeriodicChecksManualInterval|null|undefined} periodicChecksManualInterval
         * @memberof connection_request.ConnectionRequest
         * @instance
         */
        ConnectionRequest.prototype.periodicChecksManualInterval = null;

        /**
         * ConnectionRequest periodicChecksDisabled.
         * @member {connection_request.IPeriodicChecksDisabled|null|undefined} periodicChecksDisabled
         * @memberof connection_request.ConnectionRequest
         * @instance
         */
        ConnectionRequest.prototype.periodicChecksDisabled = null;

        /**
         * ConnectionRequest pubsubSubscriptions.
         * @member {connection_request.IPubSubSubscriptions|null|undefined} pubsubSubscriptions
         * @memberof connection_request.ConnectionRequest
         * @instance
         */
        ConnectionRequest.prototype.pubsubSubscriptions = null;

        /**
         * ConnectionRequest inflightRequestsLimit.
         * @member {number} inflightRequestsLimit
         * @memberof connection_request.ConnectionRequest
         * @instance
         */
        ConnectionRequest.prototype.inflightRequestsLimit = 0;

        /**
         * ConnectionRequest clientAz.
         * @member {string} clientAz
         * @memberof connection_request.ConnectionRequest
         * @instance
         */
        ConnectionRequest.prototype.clientAz = "";

        /**
         * ConnectionRequest connectionTimeout.
         * @member {number} connectionTimeout
         * @memberof connection_request.ConnectionRequest
         * @instance
         */
        ConnectionRequest.prototype.connectionTimeout = 0;

        /**
         * ConnectionRequest lazyConnect.
         * @member {boolean} lazyConnect
         * @memberof connection_request.ConnectionRequest
         * @instance
         */
        ConnectionRequest.prototype.lazyConnect = false;

        /**
         * ConnectionRequest refreshTopologyFromInitialNodes.
         * @member {boolean} refreshTopologyFromInitialNodes
         * @memberof connection_request.ConnectionRequest
         * @instance
         */
        ConnectionRequest.prototype.refreshTopologyFromInitialNodes = false;

        /**
         * ConnectionRequest libName.
         * @member {string} libName
         * @memberof connection_request.ConnectionRequest
         * @instance
         */
        ConnectionRequest.prototype.libName = "";

        /**
         * ConnectionRequest rootCerts.
         * @member {Array.<Uint8Array>} rootCerts
         * @memberof connection_request.ConnectionRequest
         * @instance
         */
        ConnectionRequest.prototype.rootCerts = $util.emptyArray;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * ConnectionRequest periodicChecks.
         * @member {"periodicChecksManualInterval"|"periodicChecksDisabled"|undefined} periodicChecks
         * @memberof connection_request.ConnectionRequest
         * @instance
         */
        Object.defineProperty(ConnectionRequest.prototype, "periodicChecks", {
            get: $util.oneOfGetter($oneOfFields = ["periodicChecksManualInterval", "periodicChecksDisabled"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ConnectionRequest instance using the specified properties.
         * @function create
         * @memberof connection_request.ConnectionRequest
         * @static
         * @param {connection_request.IConnectionRequest=} [properties] Properties to set
         * @returns {connection_request.ConnectionRequest} ConnectionRequest instance
         */
        ConnectionRequest.create = function create(properties) {
            return new ConnectionRequest(properties);
        };

        /**
         * Encodes the specified ConnectionRequest message. Does not implicitly {@link connection_request.ConnectionRequest.verify|verify} messages.
         * @function encode
         * @memberof connection_request.ConnectionRequest
         * @static
         * @param {connection_request.IConnectionRequest} message ConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.addresses != null && message.addresses.length)
                for (var i = 0; i < message.addresses.length; ++i)
                    $root.connection_request.NodeAddress.encode(message.addresses[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.tlsMode != null && Object.hasOwnProperty.call(message, "tlsMode"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.tlsMode);
            if (message.clusterModeEnabled != null && Object.hasOwnProperty.call(message, "clusterModeEnabled"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.clusterModeEnabled);
            if (message.requestTimeout != null && Object.hasOwnProperty.call(message, "requestTimeout"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.requestTimeout);
            if (message.readFrom != null && Object.hasOwnProperty.call(message, "readFrom"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.readFrom);
            if (message.connectionRetryStrategy != null && Object.hasOwnProperty.call(message, "connectionRetryStrategy"))
                $root.connection_request.ConnectionRetryStrategy.encode(message.connectionRetryStrategy, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.authenticationInfo != null && Object.hasOwnProperty.call(message, "authenticationInfo"))
                $root.connection_request.AuthenticationInfo.encode(message.authenticationInfo, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.databaseId != null && Object.hasOwnProperty.call(message, "databaseId"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.databaseId);
            if (message.protocol != null && Object.hasOwnProperty.call(message, "protocol"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.protocol);
            if (message.clientName != null && Object.hasOwnProperty.call(message, "clientName"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.clientName);
            if (message.periodicChecksManualInterval != null && Object.hasOwnProperty.call(message, "periodicChecksManualInterval"))
                $root.connection_request.PeriodicChecksManualInterval.encode(message.periodicChecksManualInterval, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.periodicChecksDisabled != null && Object.hasOwnProperty.call(message, "periodicChecksDisabled"))
                $root.connection_request.PeriodicChecksDisabled.encode(message.periodicChecksDisabled, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.pubsubSubscriptions != null && Object.hasOwnProperty.call(message, "pubsubSubscriptions"))
                $root.connection_request.PubSubSubscriptions.encode(message.pubsubSubscriptions, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.inflightRequestsLimit != null && Object.hasOwnProperty.call(message, "inflightRequestsLimit"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.inflightRequestsLimit);
            if (message.clientAz != null && Object.hasOwnProperty.call(message, "clientAz"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.clientAz);
            if (message.connectionTimeout != null && Object.hasOwnProperty.call(message, "connectionTimeout"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.connectionTimeout);
            if (message.lazyConnect != null && Object.hasOwnProperty.call(message, "lazyConnect"))
                writer.uint32(/* id 17, wireType 0 =*/136).bool(message.lazyConnect);
            if (message.refreshTopologyFromInitialNodes != null && Object.hasOwnProperty.call(message, "refreshTopologyFromInitialNodes"))
                writer.uint32(/* id 18, wireType 0 =*/144).bool(message.refreshTopologyFromInitialNodes);
            if (message.libName != null && Object.hasOwnProperty.call(message, "libName"))
                writer.uint32(/* id 19, wireType 2 =*/154).string(message.libName);
            if (message.rootCerts != null && message.rootCerts.length)
                for (var i = 0; i < message.rootCerts.length; ++i)
                    writer.uint32(/* id 20, wireType 2 =*/162).bytes(message.rootCerts[i]);
            return writer;
        };

        /**
         * Encodes the specified ConnectionRequest message, length delimited. Does not implicitly {@link connection_request.ConnectionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof connection_request.ConnectionRequest
         * @static
         * @param {connection_request.IConnectionRequest} message ConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
        };

        /**
         * Decodes a ConnectionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof connection_request.ConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {connection_request.ConnectionRequest} ConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectionRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.connection_request.ConnectionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.addresses && message.addresses.length))
                            message.addresses = [];
                        message.addresses.push($root.connection_request.NodeAddress.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.tlsMode = reader.int32();
                        break;
                    }
                case 3: {
                        message.clusterModeEnabled = reader.bool();
                        break;
                    }
                case 4: {
                        message.requestTimeout = reader.uint32();
                        break;
                    }
                case 5: {
                        message.readFrom = reader.int32();
                        break;
                    }
                case 6: {
                        message.connectionRetryStrategy = $root.connection_request.ConnectionRetryStrategy.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.authenticationInfo = $root.connection_request.AuthenticationInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.databaseId = reader.uint32();
                        break;
                    }
                case 9: {
                        message.protocol = reader.int32();
                        break;
                    }
                case 10: {
                        message.clientName = reader.string();
                        break;
                    }
                case 11: {
                        message.periodicChecksManualInterval = $root.connection_request.PeriodicChecksManualInterval.decode(reader, reader.uint32());
                        break;
                    }
                case 12: {
                        message.periodicChecksDisabled = $root.connection_request.PeriodicChecksDisabled.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.pubsubSubscriptions = $root.connection_request.PubSubSubscriptions.decode(reader, reader.uint32());
                        break;
                    }
                case 14: {
                        message.inflightRequestsLimit = reader.uint32();
                        break;
                    }
                case 15: {
                        message.clientAz = reader.string();
                        break;
                    }
                case 16: {
                        message.connectionTimeout = reader.uint32();
                        break;
                    }
                case 17: {
                        message.lazyConnect = reader.bool();
                        break;
                    }
                case 18: {
                        message.refreshTopologyFromInitialNodes = reader.bool();
                        break;
                    }
                case 19: {
                        message.libName = reader.string();
                        break;
                    }
                case 20: {
                        if (!(message.rootCerts && message.rootCerts.length))
                            message.rootCerts = [];
                        message.rootCerts.push(reader.bytes());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConnectionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof connection_request.ConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {connection_request.ConnectionRequest} ConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Gets the default type url for ConnectionRequest
         * @function getTypeUrl
         * @memberof connection_request.ConnectionRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ConnectionRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/connection_request.ConnectionRequest";
        };

        return ConnectionRequest;
    })();

    connection_request.ConnectionRetryStrategy = (function() {

        /**
         * Properties of a ConnectionRetryStrategy.
         * @memberof connection_request
         * @interface IConnectionRetryStrategy
         * @property {number|null} [numberOfRetries] ConnectionRetryStrategy numberOfRetries
         * @property {number|null} [factor] ConnectionRetryStrategy factor
         * @property {number|null} [exponentBase] ConnectionRetryStrategy exponentBase
         * @property {number|null} [jitterPercent] ConnectionRetryStrategy jitterPercent
         */

        /**
         * Constructs a new ConnectionRetryStrategy.
         * @memberof connection_request
         * @classdesc Represents a ConnectionRetryStrategy.
         * @implements IConnectionRetryStrategy
         * @constructor
         * @param {connection_request.IConnectionRetryStrategy=} [properties] Properties to set
         */
        function ConnectionRetryStrategy(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConnectionRetryStrategy numberOfRetries.
         * @member {number} numberOfRetries
         * @memberof connection_request.ConnectionRetryStrategy
         * @instance
         */
        ConnectionRetryStrategy.prototype.numberOfRetries = 0;

        /**
         * ConnectionRetryStrategy factor.
         * @member {number} factor
         * @memberof connection_request.ConnectionRetryStrategy
         * @instance
         */
        ConnectionRetryStrategy.prototype.factor = 0;

        /**
         * ConnectionRetryStrategy exponentBase.
         * @member {number} exponentBase
         * @memberof connection_request.ConnectionRetryStrategy
         * @instance
         */
        ConnectionRetryStrategy.prototype.exponentBase = 0;

        /**
         * ConnectionRetryStrategy jitterPercent.
         * @member {number|null|undefined} jitterPercent
         * @memberof connection_request.ConnectionRetryStrategy
         * @instance
         */
        ConnectionRetryStrategy.prototype.jitterPercent = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * ConnectionRetryStrategy _jitterPercent.
         * @member {"jitterPercent"|undefined} _jitterPercent
         * @memberof connection_request.ConnectionRetryStrategy
         * @instance
         */
        Object.defineProperty(ConnectionRetryStrategy.prototype, "_jitterPercent", {
            get: $util.oneOfGetter($oneOfFields = ["jitterPercent"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ConnectionRetryStrategy instance using the specified properties.
         * @function create
         * @memberof connection_request.ConnectionRetryStrategy
         * @static
         * @param {connection_request.IConnectionRetryStrategy=} [properties] Properties to set
         * @returns {connection_request.ConnectionRetryStrategy} ConnectionRetryStrategy instance
         */
        ConnectionRetryStrategy.create = function create(properties) {
            return new ConnectionRetryStrategy(properties);
        };

        /**
         * Encodes the specified ConnectionRetryStrategy message. Does not implicitly {@link connection_request.ConnectionRetryStrategy.verify|verify} messages.
         * @function encode
         * @memberof connection_request.ConnectionRetryStrategy
         * @static
         * @param {connection_request.IConnectionRetryStrategy} message ConnectionRetryStrategy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectionRetryStrategy.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.numberOfRetries != null && Object.hasOwnProperty.call(message, "numberOfRetries"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.numberOfRetries);
            if (message.factor != null && Object.hasOwnProperty.call(message, "factor"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.factor);
            if (message.exponentBase != null && Object.hasOwnProperty.call(message, "exponentBase"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.exponentBase);
            if (message.jitterPercent != null && Object.hasOwnProperty.call(message, "jitterPercent"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.jitterPercent);
            return writer;
        };

        /**
         * Encodes the specified ConnectionRetryStrategy message, length delimited. Does not implicitly {@link connection_request.ConnectionRetryStrategy.verify|verify} messages.
         * @function encodeDelimited
         * @memberof connection_request.ConnectionRetryStrategy
         * @static
         * @param {connection_request.IConnectionRetryStrategy} message ConnectionRetryStrategy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectionRetryStrategy.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
        };

        /**
         * Decodes a ConnectionRetryStrategy message from the specified reader or buffer.
         * @function decode
         * @memberof connection_request.ConnectionRetryStrategy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {connection_request.ConnectionRetryStrategy} ConnectionRetryStrategy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectionRetryStrategy.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.connection_request.ConnectionRetryStrategy();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.numberOfRetries = reader.uint32();
                        break;
                    }
                case 2: {
                        message.factor = reader.uint32();
                        break;
                    }
                case 3: {
                        message.exponentBase = reader.uint32();
                        break;
                    }
                case 4: {
                        message.jitterPercent = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConnectionRetryStrategy message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof connection_request.ConnectionRetryStrategy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {connection_request.ConnectionRetryStrategy} ConnectionRetryStrategy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectionRetryStrategy.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Gets the default type url for ConnectionRetryStrategy
         * @function getTypeUrl
         * @memberof connection_request.ConnectionRetryStrategy
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ConnectionRetryStrategy.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/connection_request.ConnectionRetryStrategy";
        };

        return ConnectionRetryStrategy;
    })();

    return connection_request;
})();

$root.response = (function() {

    /**
     * Namespace response.
     * @exports response
     * @namespace
     */
    var response = {};

    /**
     * RequestErrorType enum.
     * @name response.RequestErrorType
     * @enum {number}
     * @property {number} Unspecified=0 Unspecified value
     * @property {number} ExecAbort=1 ExecAbort value
     * @property {number} Timeout=2 Timeout value
     * @property {number} Disconnect=3 Disconnect value
     */
    response.RequestErrorType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Unspecified"] = 0;
        values[valuesById[1] = "ExecAbort"] = 1;
        values[valuesById[2] = "Timeout"] = 2;
        values[valuesById[3] = "Disconnect"] = 3;
        return values;
    })();

    response.RequestError = (function() {

        /**
         * Properties of a RequestError.
         * @memberof response
         * @interface IRequestError
         * @property {response.RequestErrorType|null} [type] RequestError type
         * @property {string|null} [message] RequestError message
         */

        /**
         * Constructs a new RequestError.
         * @memberof response
         * @classdesc Represents a RequestError.
         * @implements IRequestError
         * @constructor
         * @param {response.IRequestError=} [properties] Properties to set
         */
        function RequestError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RequestError type.
         * @member {response.RequestErrorType} type
         * @memberof response.RequestError
         * @instance
         */
        RequestError.prototype.type = 0;

        /**
         * RequestError message.
         * @member {string} message
         * @memberof response.RequestError
         * @instance
         */
        RequestError.prototype.message = "";

        /**
         * Creates a new RequestError instance using the specified properties.
         * @function create
         * @memberof response.RequestError
         * @static
         * @param {response.IRequestError=} [properties] Properties to set
         * @returns {response.RequestError} RequestError instance
         */
        RequestError.create = function create(properties) {
            return new RequestError(properties);
        };

        /**
         * Encodes the specified RequestError message. Does not implicitly {@link response.RequestError.verify|verify} messages.
         * @function encode
         * @memberof response.RequestError
         * @static
         * @param {response.IRequestError} message RequestError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
            return writer;
        };

        /**
         * Encodes the specified RequestError message, length delimited. Does not implicitly {@link response.RequestError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof response.RequestError
         * @static
         * @param {response.IRequestError} message RequestError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
        };

        /**
         * Decodes a RequestError message from the specified reader or buffer.
         * @function decode
         * @memberof response.RequestError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {response.RequestError} RequestError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestError.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.response.RequestError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.message = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RequestError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof response.RequestError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {response.RequestError} RequestError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Gets the default type url for RequestError
         * @function getTypeUrl
         * @memberof response.RequestError
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RequestError.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/response.RequestError";
        };

        return RequestError;
    })();

    response.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof response
         * @interface IResponse
         * @property {number|null} [callbackIdx] Response callbackIdx
         * @property {number|Long|null} [respPointer] Response respPointer
         * @property {response.ConstantResponse|null} [constantResponse] Response constantResponse
         * @property {response.IRequestError|null} [requestError] Response requestError
         * @property {string|null} [closingError] Response closingError
         * @property {boolean|null} [isPush] Response isPush
         * @property {number|Long|null} [rootSpanPtr] Response rootSpanPtr
         */

        /**
         * Constructs a new Response.
         * @memberof response
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {response.IResponse=} [properties] Properties to set
         */
        function Response(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Response callbackIdx.
         * @member {number} callbackIdx
         * @memberof response.Response
         * @instance
         */
        Response.prototype.callbackIdx = 0;

        /**
         * Response respPointer.
         * @member {number|Long|null|undefined} respPointer
         * @memberof response.Response
         * @instance
         */
        Response.prototype.respPointer = null;

        /**
         * Response constantResponse.
         * @member {response.ConstantResponse|null|undefined} constantResponse
         * @memberof response.Response
         * @instance
         */
        Response.prototype.constantResponse = null;

        /**
         * Response requestError.
         * @member {response.IRequestError|null|undefined} requestError
         * @memberof response.Response
         * @instance
         */
        Response.prototype.requestError = null;

        /**
         * Response closingError.
         * @member {string|null|undefined} closingError
         * @memberof response.Response
         * @instance
         */
        Response.prototype.closingError = null;

        /**
         * Response isPush.
         * @member {boolean} isPush
         * @memberof response.Response
         * @instance
         */
        Response.prototype.isPush = false;

        /**
         * Response rootSpanPtr.
         * @member {number|Long|null|undefined} rootSpanPtr
         * @memberof response.Response
         * @instance
         */
        Response.prototype.rootSpanPtr = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Response value.
         * @member {"respPointer"|"constantResponse"|"requestError"|"closingError"|undefined} value
         * @memberof response.Response
         * @instance
         */
        Object.defineProperty(Response.prototype, "value", {
            get: $util.oneOfGetter($oneOfFields = ["respPointer", "constantResponse", "requestError", "closingError"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Response _rootSpanPtr.
         * @member {"rootSpanPtr"|undefined} _rootSpanPtr
         * @memberof response.Response
         * @instance
         */
        Object.defineProperty(Response.prototype, "_rootSpanPtr", {
            get: $util.oneOfGetter($oneOfFields = ["rootSpanPtr"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof response.Response
         * @static
         * @param {response.IResponse=} [properties] Properties to set
         * @returns {response.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link response.Response.verify|verify} messages.
         * @function encode
         * @memberof response.Response
         * @static
         * @param {response.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callbackIdx != null && Object.hasOwnProperty.call(message, "callbackIdx"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.callbackIdx);
            if (message.respPointer != null && Object.hasOwnProperty.call(message, "respPointer"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.respPointer);
            if (message.constantResponse != null && Object.hasOwnProperty.call(message, "constantResponse"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.constantResponse);
            if (message.requestError != null && Object.hasOwnProperty.call(message, "requestError"))
                $root.response.RequestError.encode(message.requestError, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.closingError != null && Object.hasOwnProperty.call(message, "closingError"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.closingError);
            if (message.isPush != null && Object.hasOwnProperty.call(message, "isPush"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isPush);
            if (message.rootSpanPtr != null && Object.hasOwnProperty.call(message, "rootSpanPtr"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.rootSpanPtr);
            return writer;
        };

        /**
         * Encodes the specified Response message, length delimited. Does not implicitly {@link response.Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof response.Response
         * @static
         * @param {response.IResponse} message Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof response.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {response.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.response.Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.callbackIdx = reader.uint32();
                        break;
                    }
                case 2: {
                        message.respPointer = reader.uint64();
                        break;
                    }
                case 3: {
                        message.constantResponse = reader.int32();
                        break;
                    }
                case 4: {
                        message.requestError = $root.response.RequestError.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.closingError = reader.string();
                        break;
                    }
                case 6: {
                        message.isPush = reader.bool();
                        break;
                    }
                case 7: {
                        message.rootSpanPtr = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof response.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {response.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Gets the default type url for Response
         * @function getTypeUrl
         * @memberof response.Response
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Response.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/response.Response";
        };

        return Response;
    })();

    /**
     * ConstantResponse enum.
     * @name response.ConstantResponse
     * @enum {number}
     * @property {number} OK=0 OK value
     */
    response.ConstantResponse = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OK"] = 0;
        return values;
    })();

    return response;
})();

module.exports = $root;
