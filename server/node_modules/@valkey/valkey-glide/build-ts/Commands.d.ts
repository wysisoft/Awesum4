/**
 * Copyright Valkey GLIDE Project Contributors - SPDX Identifier: Apache-2.0
 */
import { GlideString, HashDataType, ObjectType } from "./BaseClient";
import { SingleNodeRoute } from "./GlideClusterClient";
/**
 * @test
 */
export declare function parseInfoResponse(response: string): Record<string, string>;
export type SetOptions = ({
    /**
     * `onlyIfDoesNotExist` - Only set the key if it does not already exist.
     * `NX` in the Valkey API.
     *
     * `onlyIfExists` - Only set the key if it already exists.
     * `EX` in the Valkey API.
     */
    conditionalSet?: "onlyIfExists" | "onlyIfDoesNotExist";
} | {
    /**
     * `onlyIfEqual` - Only set the key if the comparison value equals the current value of key.
     * `IFEQ` in the Valkey API.
     */
    conditionalSet: "onlyIfEqual";
    /**
     * The value to compare the existing value with.
     */
    comparisonValue: GlideString;
}) & {
    /**
     * Return the old string stored at key, or nil if key did not exist. An error
     * is returned and SET aborted if the value stored at key is not a string.
     * Equivalent to `GET` in the Valkey API.
     */
    returnOldValue?: boolean;
    /**
     * @example
     * ```javascript
     *
     *  import {TimeUnit} from "@valkey/valkey-glide";
     *
     *  await client.set(key, JSON.stringify(key), {
     *   expiry: {
     *       type: TimeUnit.Seconds,
     *       count: 60,
     *      },
     *  });
     * ```
     *
     * If not set, no expiry time will be set for the value.
     *
     * `keepExisting` - Retain the time to live associated with the key.
     * Equivalent to `KEEPTTL` in the Valkey API.
     */
    expiry?: "keepExisting" | {
        type: TimeUnit;
        count: number;
    };
};
/**
 * INFO option: a specific section of information:
 * When no parameter is provided, the default option is assumed.
 */
export declare enum InfoOptions {
    /**
     * SERVER: General information about the server
     */
    Server = "server",
    /**
     * CLIENTS: Client connections section
     */
    Clients = "clients",
    /**
     * MEMORY: Memory consumption related information
     */
    Memory = "memory",
    /**
     * PERSISTENCE: RDB and AOF related information
     */
    Persistence = "persistence",
    /**
     * STATS: General statistics
     */
    Stats = "stats",
    /**
     * REPLICATION: Master/replica replication information
     */
    Replication = "replication",
    /**
     * CPU: CPU consumption statistics
     */
    Cpu = "cpu",
    /**
     * COMMANDSTATS: Valkey command statistics
     */
    Commandstats = "commandstats",
    /**
     * LATENCYSTATS: Valkey command latency percentile distribution statistics
     */
    Latencystats = "latencystats",
    /**
     * SENTINEL: Valkey Sentinel section (only applicable to Sentinel instances)
     */
    Sentinel = "sentinel",
    /**
     * CLUSTER: Valkey Cluster section
     */
    Cluster = "cluster",
    /**
     * MODULES: Modules section
     */
    Modules = "modules",
    /**
     * KEYSPACE: Database related statistics
     */
    Keyspace = "keyspace",
    /**
     * ERRORSTATS: Valkey error statistics
     */
    Errorstats = "errorstats",
    /**
     * ALL: Return all sections (excluding module generated ones)
     */
    All = "all",
    /**
     * DEFAULT: Return only the default set of sections
     */
    Default = "default",
    /**
     * EVERYTHING: Includes all and modules
     */
    Everything = "everything"
}
/**
 * This function converts an input from {@link HashDataType} or `Record` types to `HashDataType`.
 *
 * @param fieldsAndValues - field names and their values.
 * @returns HashDataType array containing field names and their values.
 */
export declare function convertFieldsAndValuesToHashDataType(fieldsAndValues: HashDataType | Record<string, GlideString>): HashDataType;
/**
 * Enumeration defining the bitwise operation to use in the {@link BaseClient.bitop|bitop} command. Specifies the
 * bitwise operation to perform between the passed in keys.
 */
export declare enum BitwiseOperation {
    AND = "AND",
    OR = "OR",
    XOR = "XOR",
    NOT = "NOT"
}
/**
 * Represents a signed or unsigned argument encoding for the {@link BaseClient.bitfield|bitfield} or
 * {@link BaseClient.bitfieldReadOnly|bitfieldReadOnly} commands.
 */
export interface BitEncoding {
    /**
     * Returns the encoding as a string argument to be used in the {@link BaseClient.bitfield|bitfield} or
     * {@link BaseClient.bitfieldReadOnly|bitfieldReadOnly} commands.
     *
     * @returns The encoding as a string argument.
     */
    toArg(): string;
}
/**
 * Represents a signed argument encoding.
 */
export declare class SignedEncoding implements BitEncoding {
    private static readonly SIGNED_ENCODING_PREFIX;
    private readonly encoding;
    /**
     * Creates an instance of SignedEncoding.
     *
     * @param encodingLength - The bit size of the encoding. Must be less than 65 bits long.
     */
    constructor(encodingLength: number);
    toArg(): string;
}
/**
 * Represents an unsigned argument encoding.
 */
export declare class UnsignedEncoding implements BitEncoding {
    private static readonly UNSIGNED_ENCODING_PREFIX;
    private readonly encoding;
    /**
     * Creates an instance of UnsignedEncoding.
     *
     * @param encodingLength - The bit size of the encoding. Must be less than 64 bits long.
     */
    constructor(encodingLength: number);
    toArg(): string;
}
/**
 * Represents an offset for an array of bits for the {@link BaseClient.bitfield|bitfield} or
 * {@link BaseClient.bitfieldReadOnly|bitfieldReadOnly} commands.
 */
export interface BitFieldOffset {
    /**
     * Returns the offset as a string argument to be used in the {@link BaseClient.bitfield|bitfield} or
     * {@link BaseClient.bitfieldReadOnly|bitfieldReadOnly} commands.
     *
     * @returns The offset as a string argument.
     */
    toArg(): string;
}
/**
 * Represents an offset in an array of bits for the {@link BaseClient.bitfield|bitfield} or
 * {@link BaseClient.bitfieldReadOnly|bitfieldReadOnly} commands.
 *
 * For example, if we have the binary `01101001` with offset of 1 for an unsigned encoding of size 4, then the value
 * is 13 from `0(1101)001`.
 */
export declare class BitOffset implements BitFieldOffset {
    private readonly offset;
    /**
     * Creates an instance of BitOffset.
     *
     * @param offset - The bit index offset in the array of bits. Must be greater than or equal to 0.
     */
    constructor(offset: number);
    toArg(): string;
}
/**
 * Represents an offset in an array of bits for the {@link BaseClient.bitfield|bitfield} or
 * {@link BaseClient.bitfieldReadOnly|bitfieldReadOnly} commands. The bit offset index is calculated as the numerical
 * value of the offset multiplied by the encoding value.
 *
 * For example, if we have the binary 01101001 with offset multiplier of 1 for an unsigned encoding of size 4, then the
 * value is 9 from `0110(1001)`.
 */
export declare class BitOffsetMultiplier implements BitFieldOffset {
    private static readonly OFFSET_MULTIPLIER_PREFIX;
    private readonly offset;
    /**
     * Creates an instance of BitOffsetMultiplier.
     *
     * @param offset - The offset in the array of bits, which will be multiplied by the encoding value to get the final
     *      bit index offset.
     */
    constructor(offset: number);
    toArg(): string;
}
/**
 * Represents subcommands for the {@link BaseClient.bitfield|bitfield} or
 * {@link BaseClient.bitfieldReadOnly|bitfieldReadOnly} commands.
 */
export interface BitFieldSubCommands {
    /**
     * Returns the subcommand as a list of string arguments to be used in the {@link BaseClient.bitfield|bitfield} or
     * {@link BaseClient.bitfieldReadOnly|bitfieldReadOnly} commands.
     *
     * @returns The subcommand as a list of string arguments.
     */
    toArgs(): string[];
}
/**
 * Represents the "GET" subcommand for getting a value in the binary representation of the string stored in `key`.
 */
export declare class BitFieldGet implements BitFieldSubCommands {
    private static readonly GET_COMMAND_STRING;
    private readonly encoding;
    private readonly offset;
    /**
     * Creates an instance of BitFieldGet.
     *
     * @param encoding - The bit encoding for the subcommand.
     * @param offset - The offset in the array of bits from which to get the value.
     */
    constructor(encoding: BitEncoding, offset: BitFieldOffset);
    toArgs(): string[];
}
/**
 * Represents the "SET" subcommand for setting bits in the binary representation of the string stored in `key`.
 */
export declare class BitFieldSet implements BitFieldSubCommands {
    private static readonly SET_COMMAND_STRING;
    private readonly encoding;
    private readonly offset;
    private readonly value;
    /**
     * Creates an instance of BitFieldSet
     *
     * @param encoding - The bit encoding for the subcommand.
     * @param offset - The offset in the array of bits where the value will be set.
     * @param value - The value to set the bits in the binary value to.
     */
    constructor(encoding: BitEncoding, offset: BitFieldOffset, value: number);
    toArgs(): string[];
}
/**
 * Represents the "INCRBY" subcommand for increasing or decreasing bits in the binary representation of the string
 * stored in `key`.
 */
export declare class BitFieldIncrBy implements BitFieldSubCommands {
    private static readonly INCRBY_COMMAND_STRING;
    private readonly encoding;
    private readonly offset;
    private readonly increment;
    /**
     * Creates an instance of BitFieldIncrBy
     *
     * @param encoding - The bit encoding for the subcommand.
     * @param offset - The offset in the array of bits where the value will be incremented.
     * @param increment - The value to increment the bits in the binary value by.
     */
    constructor(encoding: BitEncoding, offset: BitFieldOffset, increment: number);
    toArgs(): string[];
}
/**
 * Enumeration specifying bit overflow controls for the {@link BaseClient.bitfield|bitfield} command.
 */
export declare enum BitOverflowControl {
    /**
     * Performs modulo when overflows occur with unsigned encoding. When overflows occur with signed encoding, the value
     * restarts at the most negative value. When underflows occur with signed encoding, the value restarts at the most
     * positive value.
     */
    WRAP = "WRAP",
    /**
     * Underflows remain set to the minimum value, and overflows remain set to the maximum value.
     */
    SAT = "SAT",
    /**
     * Returns `None` when overflows occur.
     */
    FAIL = "FAIL"
}
/**
 * Represents the "OVERFLOW" subcommand that determines the result of the "SET" or "INCRBY"
 * {@link BaseClient.bitfield|bitfield} subcommands when an underflow or overflow occurs.
 */
export declare class BitFieldOverflow implements BitFieldSubCommands {
    private static readonly OVERFLOW_COMMAND_STRING;
    private readonly overflowControl;
    /**
     * Creates an instance of BitFieldOverflow.
     *
     * @param overflowControl - The desired overflow behavior.
     */
    constructor(overflowControl: BitOverflowControl);
    toArgs(): string[];
}
/**
 * Enumeration representing element popping or adding direction for the List Based Commands.
 */
export declare enum ListDirection {
    /**
     * Represents the option that elements should be popped from or added to the left side of a list.
     */
    LEFT = "LEFT",
    /**
     * Represents the option that elements should be popped from or added to the right side of a list.
     */
    RIGHT = "RIGHT"
}
export declare enum ExpireOptions {
    /**
     * `HasNoExpiry` - Sets expiry only when the key has no expiry.
     */
    HasNoExpiry = "NX",
    /**
     * `HasExistingExpiry` - Sets expiry only when the key has an existing expiry.
     */
    HasExistingExpiry = "XX",
    /**
     * `NewExpiryGreaterThanCurrent` - Sets expiry only when the new expiry is
     * greater than current one.
     */
    NewExpiryGreaterThanCurrent = "GT",
    /**
     * `NewExpiryLessThanCurrent` - Sets expiry only when the new expiry is less
     * than current one.
     */
    NewExpiryLessThanCurrent = "LT"
}
/**
 * Options for updating elements of a sorted set key.
 */
export declare enum UpdateByScore {
    /** Only update existing elements if the new score is less than the current score. */
    LESS_THAN = "LT",
    /** Only update existing elements if the new score is greater than the current score. */
    GREATER_THAN = "GT"
}
export interface ZAddOptions {
    /**
     * Options for handling existing members.
     */
    conditionalChange?: ConditionalChange;
    /**
     * Options for updating scores.
     */
    updateOptions?: UpdateByScore;
    /**
     * Modify the return value from the number of new elements added, to the total number of elements changed.
     */
    changed?: boolean;
}
/**
 * `KeyWeight` - pair of variables represents a weighted key for the `ZINTERSTORE` and `ZUNIONSTORE` sorted sets commands.
 */
export type KeyWeight = [GlideString, number];
/**
 * `AggregationType` - representing aggregation types for `ZINTERSTORE` and `ZUNIONSTORE` sorted set commands.
 */
export type AggregationType = "SUM" | "MIN" | "MAX";
export declare enum InfBoundary {
    /**
     * Positive infinity bound.
     */
    PositiveInfinity = "+",
    /**
     * Negative infinity bound.
     */
    NegativeInfinity = "-"
}
/**
 * Defines the boundaries of a range.
 */
export type Boundary<T> = 
/**
 *  Represents an lower/upper boundary.
 */
InfBoundary
/**
 *  Represents a specific boundary.
 */
 | {
    /**
     * The comparison value.
     */
    value: T;
    /**
     * Whether the value is inclusive. Defaults to `true`.
     */
    isInclusive?: boolean;
};
/**
 * Represents a range by index (rank) in a sorted set.
 * The `start` and `end` arguments represent zero-based indexes.
 */
export interface RangeByIndex {
    /**
     * The start index of the range.
     */
    start: number;
    /**
     * The end index of the range.
     */
    end: number;
}
/**
 * Represents a range by score or a range by lex in a sorted set.
 * The `start` and `end` arguments represent score boundaries.
 */
interface SortedSetRange<T> {
    /**
     * The start boundary.
     */
    start: Boundary<T>;
    /**
     * The end boundary.
     */
    end: Boundary<T>;
    /**
     * The limit argument for a range query.
     * Represents a limit argument for a range query in a sorted set to
     * be used in [ZRANGE](https://valkey.io/commands/zrange) command.
     *
     * The optional LIMIT argument can be used to obtain a sub-range from the
     * matching elements (similar to SELECT LIMIT offset, count in SQL).
     */
    limit?: {
        /**
         * The offset from the start of the range.
         */
        offset: number;
        /**
         * The number of elements to include in the range.
         * A negative count returns all elements from the offset.
         */
        count: number;
    };
}
export type RangeByScore = SortedSetRange<number> & {
    type: "byScore";
};
export type RangeByLex = SortedSetRange<GlideString> & {
    type: "byLex";
};
/**
 * Defines where to insert new elements into a list.
 */
export declare enum InsertPosition {
    /**
     * Insert new element before the pivot.
     */
    Before = "before",
    /**
     * Insert new element after the pivot.
     */
    After = "after"
}
export type StreamTrimOptions = ({
    /**
     * Trim the stream according to entry ID.
     * Equivalent to `MINID` in the Valkey API.
     */
    method: "minid";
    threshold: GlideString;
} | {
    /**
     * Trim the stream according to length.
     * Equivalent to `MAXLEN` in the Valkey API.
     */
    method: "maxlen";
    threshold: number;
}) & {
    /**
     * If `true`, the stream will be trimmed exactly. Equivalent to `=` in the
     * Valkey API. Otherwise the stream will be trimmed in a near-exact manner,
     * which is more efficient, equivalent to `~` in the Valkey API.
     */
    exact: boolean;
    /**
     * If set, sets the maximal amount of entries that will be deleted.
     */
    limit?: number;
};
export interface StreamAddOptions {
    /**
     * If set, the new entry will be added with this ID.
     */
    id?: string;
    /**
     * If set to `false`, a new stream won't be created if no stream matches the
     * given key. Equivalent to `NOMKSTREAM` in the Valkey API.
     */
    makeStream?: boolean;
    /**
     * If set, the add operation will also trim the older entries in the stream.
     */
    trim?: StreamTrimOptions;
}
/** Optional arguments for `FUNCTION LIST` command. */
export interface FunctionListOptions {
    /** A wildcard pattern for matching library names. */
    libNamePattern?: GlideString;
    /** Specifies whether to request the library code from the server or not. */
    withCode?: boolean;
}
/** Type of the response of `FUNCTION LIST` command. */
export type FunctionListResponse = Record<string, GlideString | Record<string, GlideString | null | GlideString[]>[]>[];
/** Response for `FUNCTION STATS` command on a single node.
 *  The response is a map with 2 keys:
 *  1. Information about the current running function/script (or null if none).
 *  2. Details about the execution engines.
 */
export type FunctionStatsSingleResponse = Record<string, null | Record<string, GlideString | GlideString[] | number> | Record<string, Record<string, number>>>;
/** Full response for `FUNCTION STATS` command across multiple nodes.
 *  It maps node addresses to the per-node response.
 */
export type FunctionStatsFullResponse = Record<string, // Node address
FunctionStatsSingleResponse>;
/**
 * Option for `FUNCTION RESTORE` command: {@link GlideClient.functionRestore} and
 * {@link GlideClusterClient.functionRestore}.
 *
 * @see {@link https://valkey.io/commands/function-restore/"|valkey.io} for more details.
 */
export declare enum FunctionRestorePolicy {
    /**
     * Appends the restored libraries to the existing libraries and aborts on collision. This is the
     * default policy.
     */
    APPEND = "APPEND",
    /** Deletes all existing libraries before restoring the payload. */
    FLUSH = "FLUSH",
    /**
     * Appends the restored libraries to the existing libraries, replacing any existing ones in case
     * of name collisions. Note that this policy doesn't prevent function name collisions, only
     * libraries.
     */
    REPLACE = "REPLACE"
}
/**
 * Represents offsets specifying a string interval to analyze in the {@link BaseClient.bitcount | bitcount} and {@link BaseClient.bitpos | bitpos} commands.
 * The offsets are zero-based indexes, with `0` being the first index of the string, `1` being the next index and so on.
 * The offsets can also be negative numbers indicating offsets starting at the end of the string, with `-1` being
 * the last index of the string, `-2` being the penultimate, and so on.
 *
 * If you are using Valkey 7.0.0 or above, the optional `indexType` can also be provided to specify whether the
 * `start` and `end` offsets specify `BIT` or `BYTE` offsets. If `indexType` is not provided, `BYTE` offsets
 * are assumed. If `BIT` is specified, `start=0` and `end=2` means to look at the first three bits. If `BYTE` is
 * specified, `start=0` and `end=2` means to look at the first three bytes.
 *
 * @see {@link https://valkey.io/commands/bitcount/ | bitcount} and {@link https://valkey.io/commands/bitpos/ | bitpos} for more details.
 */
export interface BitOffsetOptions {
    /** The starting offset index. */
    start: number;
    /**
     * The ending offset index. Optional since Valkey version 8.0 and above for the BITCOUNT command.
     * If not provided, it will default to the end of the string.
     * Could be defined only if `start` is defined.
     */
    end?: number;
    /**
     * The index offset type. This option can only be specified if you are using server version 7.0.0 or above.
     * Could be either {@link BitmapIndexType.BYTE} or {@link BitmapIndexType.BIT}.
     * If no index type is provided, the indexes will be assumed to be byte indexes.
     */
    indexType?: BitmapIndexType;
}
/**
 * Enumeration specifying if index arguments are BYTE indexes or BIT indexes.
 * Can be specified in {@link BitOffsetOptions}, which is an optional argument to the {@link BaseClient.bitcount|bitcount} command.
 * Can also be specified as an optional argument to the {@link BaseClient.bitposInverval|bitposInterval} command.
 *
 * since - Valkey version 7.0.0.
 */
export declare enum BitmapIndexType {
    /** Specifies that provided indexes are byte indexes. */
    BYTE = "BYTE",
    /** Specifies that provided indexes are bit indexes. */
    BIT = "BIT"
}
/**
 * Defines flushing mode for {@link GlideClient.flushall}, {@link GlideClusterClient.flushall},
 *      {@link GlideClient.functionFlush}, {@link GlideClusterClient.functionFlush},
 *      {@link GlideClient.flushdb} and {@link GlideClusterClient.flushdb} commands.
 *
 * See https://valkey.io/commands/flushall/ and https://valkey.io/commands/flushdb/ for details.
 */
export declare enum FlushMode {
    /**
     * Flushes synchronously.
     *
     * since Valkey version 6.2.0.
     */
    SYNC = "SYNC",
    /** Flushes asynchronously. */
    ASYNC = "ASYNC"
}
/** Optional arguments for {@link BaseClient.xread|xread} command. */
export interface StreamReadOptions {
    /**
     * If set, the read request will block for the set amount of milliseconds or
     * until the server has the required number of entries. A value of `0` will block indefinitely.
     * Equivalent to `BLOCK` in the Valkey API.
     */
    block?: number;
    /**
     * The maximal number of elements requested.
     * Equivalent to `COUNT` in the Valkey API.
     */
    count?: number;
}
/** Optional arguments for {@link BaseClient.xreadgroup|xreadgroup} command. */
export type StreamReadGroupOptions = StreamReadOptions & {
    /**
     * If set, messages are not added to the Pending Entries List (PEL). This is equivalent to
     * acknowledging the message when it is read.
     */
    noAck?: boolean;
};
/** Optional arguments for {@link BaseClient.xpendingWithOptions|xpending}. */
export interface StreamPendingOptions {
    /** Filter pending entries by their idle time - in milliseconds. Available since Valkey 6.2.0. */
    minIdleTime?: number;
    /** Starting stream ID bound for range. Exclusive range is available since Valkey 6.2.0. */
    start: Boundary<string>;
    /** Ending stream ID bound for range. Exclusive range is available since Valkey 6.2.0. */
    end: Boundary<string>;
    /** Limit the number of messages returned. */
    count: number;
    /** Filter pending entries by consumer. */
    consumer?: GlideString;
}
/** Optional parameters for {@link BaseClient.xclaim|xclaim} command. */
export interface StreamClaimOptions {
    /**
     * Set the idle time (last time it was delivered) of the message in milliseconds. If `idle`
     * is not specified, an `idle` of `0` is assumed, that is, the time count is reset
     * because the message now has a new owner trying to process it.
     */
    idle?: number;
    /**
     * This is the same as {@link idle} but instead of a relative amount of milliseconds, it sets the
     * idle time to a specific Unix time (in milliseconds). This is useful in order to rewrite the AOF
     * file generating `XCLAIM` commands.
     */
    idleUnixTime?: number;
    /**
     * Set the retry counter to the specified value. This counter is incremented every time a message
     * is delivered again. Normally {@link BaseClient.xclaim|xclaim} does not alter this counter,
     * which is just served to clients when the {@link BaseClient.xpending|xpending} command is called:
     * this way clients can detect anomalies, like messages that are never processed for some reason
     * after a big number of delivery attempts.
     */
    retryCount?: number;
    /**
     * Creates the pending message entry in the PEL even if certain specified IDs are not already in
     * the PEL assigned to a different client. However, the message must exist in the stream,
     * otherwise the IDs of non-existing messages are ignored.
     */
    isForce?: boolean;
}
/**
 * Optional arguments for {@link BaseClient.xgroupCreate|xgroupCreate}.
 *
 * See https://valkey.io/commands/xgroup-create/ for more details.
 */
export interface StreamGroupOptions {
    /**
     * If `true`and the stream doesn't exist, creates a new stream with a length of `0`.
     */
    mkStream?: boolean;
    /**
     * An arbitrary ID (that isn't the first ID, last ID, or the zero `"0-0"`. Use it to
     * find out how many entries are between the arbitrary ID (excluding it) and the stream's last
     * entry.
     *
     * since Valkey version 7.0.0.
     */
    entriesRead?: string;
}
/** Additional parameters for `LOLWUT` command. */
export interface LolwutOptions {
    /**
     * An optional argument that can be used to specify the version of computer art to generate.
     */
    version?: number;
    /**
     * An optional argument that can be used to specify the output:
     * - For version `5`, those are length of the line, number of squares per row, and number of squares per column.
     * - For version `6`, those are number of columns and number of lines.
     */
    parameters?: number[];
}
/**
 * Optional arguments for `RESTORE` command.
 *
 * @See {@link https://valkey.io/commands/restore/|valkey.io} for details.
 * @remarks `IDLETIME` and `FREQ` modifiers cannot be set at the same time.
 */
export interface RestoreOptions {
    /**
     * Set to `true` to replace the key if it exists.
     */
    replace?: boolean;
    /**
     * Set to `true` to specify that `ttl` argument of {@link BaseClient.restore} represents
     * an absolute Unix timestamp (in milliseconds).
     */
    absttl?: boolean;
    /**
     * Set the `IDLETIME` option with object idletime to the given key.
     */
    idletime?: number;
    /**
     * Set the `FREQ` option with object frequency to the given key.
     */
    frequency?: number;
}
/**
 * Optional arguments to LPOS command.
 *
 * See https://valkey.io/commands/lpos/ for more details.
 */
export interface LPosOptions {
    /** The rank of the match to return. */
    rank?: number;
    /** The specific number of matching indices from a list. */
    count?: number;
    /** The maximum number of comparisons to make between the element and the items in the list. */
    maxLength?: number;
}
/**
 * An optional condition to the {@link BaseClient.geoadd | geoadd},
 * {@link BaseClient.zadd | zadd} and {@link BaseClient.set | set} commands.
 */
export declare enum ConditionalChange {
    /**
     * Only update elements that already exist. Don't add new elements. Equivalent to `XX` in the Valkey API.
     */
    ONLY_IF_EXISTS = "XX",
    /**
     * Only add new elements. Don't update already existing elements. Equivalent to `NX` in the Valkey API.
     */
    ONLY_IF_DOES_NOT_EXIST = "NX"
}
/**
 * Field conditional change options for hash field expiration commands.
 * Used with HSETEX command to control field setting behavior.
 */
export declare enum HashFieldConditionalChange {
    /**
     * Only set fields if all of them already exist. Equivalent to `FXX` in the Valkey API.
     */
    ONLY_IF_ALL_EXIST = "FXX",
    /**
     * Only set fields if none of them already exist. Equivalent to `FNX` in the Valkey API.
     */
    ONLY_IF_NONE_EXIST = "FNX"
}
/**
 * Expiry set options for hash field expiration commands.
 * Supports setting expiration time in various formats.
 */
export type ExpirySet = {
    type: TimeUnit;
    count: number;
} | "KEEPTTL";
/**
 * Expiry options specifically for HSETEX command.
 * Supports standard expiry options (EX/PX/EXAT/PXAT) and KEEPTTL, but excludes PERSIST.
 *
 * @example
 * ```typescript
 * // Set expiration to 60 seconds
 * const expiry: HSetExExpiry = { type: TimeUnit.Seconds, count: 60 };
 *
 * // Keep existing TTL
 * const keepTtl: HSetExExpiry = "KEEPTTL";
 * ```
 */
export type HSetExExpiry = {
    type: TimeUnit;
    count: number;
} | "KEEPTTL";
/**
 * Expiry options specifically for HGETEX command.
 * Supports standard expiry options (EX/PX/EXAT/PXAT) and PERSIST, but excludes KEEPTTL.
 *
 * @example
 * ```typescript
 * // Set expiration to 30 seconds
 * const expiry: HGetExExpiry = { type: TimeUnit.Seconds, count: 30 };
 *
 * // Remove expiration
 * const persist: HGetExExpiry = "PERSIST";
 * ```
 */
export type HGetExExpiry = {
    type: TimeUnit;
    count: number;
} | "PERSIST";
/**
 * Optional arguments for the HSETEX command.
 *
 * @example
 * ```typescript
 * // Set fields with 60 second expiration, only if none exist
 * const options: HSetExOptions = {
 *     fieldConditionalChange: HashFieldConditionalChange.ONLY_IF_NONE_EXIST,
 *     expiry: { type: TimeUnit.Seconds, count: 60 }
 * };
 *
 * // Set fields and keep existing TTL
 * const keepTtlOptions: HSetExOptions = {
 *     expiry: "KEEPTTL"
 * };
 * ```
 *
 * See https://valkey.io/commands/hsetex/ for more details.
 */
export interface HSetExOptions {
    /** Options for handling existing fields. See {@link HashFieldConditionalChange}. */
    fieldConditionalChange?: HashFieldConditionalChange;
    /** Expiry settings for the fields. See {@link HSetExExpiry}. */
    expiry?: HSetExExpiry;
}
/**
 * Optional arguments for the HGETEX command.
 *
 * @example
 * ```typescript
 * // Get fields and set 30 second expiration
 * const options: HGetExOptions = {
 *     expiry: { type: TimeUnit.Seconds, count: 30 }
 * };
 *
 * // Get fields and remove expiration
 * const persistOptions: HGetExOptions = {
 *     expiry: "PERSIST"
 * };
 * ```
 *
 * See https://valkey.io/commands/hgetex/ for more details.
 */
export interface HGetExOptions {
    /** Expiry settings for the fields. Can be a time-based expiry or "PERSIST" to remove expiration. */
    expiry?: HGetExExpiry;
}
/**
 * Expiration condition options for hash field expiration commands.
 * Used with HEXPIRE, HPEXPIRE, HEXPIREAT, and HPEXPIREAT commands to control expiration setting behavior.
 */
export declare enum HashExpirationCondition {
    /**
     * Only set expiration when field has no expiration. Equivalent to `NX` in the Valkey API.
     */
    ONLY_IF_NO_EXPIRY = "NX",
    /**
     * Only set expiration when field has existing expiration. Equivalent to `XX` in the Valkey API.
     */
    ONLY_IF_HAS_EXPIRY = "XX",
    /**
     * Only set expiration when new expiration is greater than current. Equivalent to `GT` in the Valkey API.
     */
    ONLY_IF_GREATER_THAN_CURRENT = "GT",
    /**
     * Only set expiration when new expiration is less than current. Equivalent to `LT` in the Valkey API.
     */
    ONLY_IF_LESS_THAN_CURRENT = "LT"
}
/**
 * Shared optional arguments for HEXPIRE, HPEXPIRE, HEXPIREAT, and HPEXPIREAT commands.
 *
 * This interface provides a unified way to specify expiration conditions for hash field
 * expiration commands that support conditional expiration setting.
 *
 * @example
 * ```typescript
 * // Set expiration only if field has no existing expiration
 * const options: HExpireOptions = {
 *     condition: HashExpirationCondition.ONLY_IF_NO_EXPIRY
 * };
 *
 * // Set expiration only if new expiration is greater than current
 * const gtOptions: HExpireOptions = {
 *     condition: HashExpirationCondition.ONLY_IF_GREATER_THAN_CURRENT
 * };
 *
 * // Set expiration only if field has existing expiration
 * const xxOptions: HExpireOptions = {
 *     condition: HashExpirationCondition.ONLY_IF_HAS_EXPIRY
 * };
 *
 * // Set expiration only if new expiration is less than current
 * const ltOptions: HExpireOptions = {
 *     condition: HashExpirationCondition.ONLY_IF_LESS_THAN_CURRENT
 * };
 * ```
 *
 * @see {@link https://valkey.io/commands/hexpire/|HEXPIRE}
 * @see {@link https://valkey.io/commands/hpexpire/|HPEXPIRE}
 * @see {@link https://valkey.io/commands/hexpireat/|HEXPIREAT}
 * @see {@link https://valkey.io/commands/hpexpireat/|HPEXPIREAT}
 */
export interface HExpireOptions {
    /**
     * Condition for setting expiration. Controls when the expiration should be set
     * based on the current state of the field's expiration.
     * See {@link HashExpirationCondition} for available options.
     */
    condition?: HashExpirationCondition;
}
/**
 * Represents a geographic position defined by longitude and latitude.
 * The exact limits, as specified by `EPSG:900913 / EPSG:3785 / OSGEO:41001` are the
 * following:
 *
 *   Valid longitudes are from `-180` to `180` degrees.
 *   Valid latitudes are from `-85.05112878` to `85.05112878` degrees.
 */
export interface GeospatialData {
    /** The longitude coordinate. */
    longitude: number;
    /** The latitude coordinate. */
    latitude: number;
}
/**
 * Optional arguments for the GeoAdd command.
 *
 * See https://valkey.io/commands/geoadd/ for more details.
 */
export interface GeoAddOptions {
    /** Options for handling existing members. See {@link ConditionalChange}. */
    updateMode?: ConditionalChange;
    /** If `true`, returns the count of changed elements instead of new elements added. */
    changed?: boolean;
}
/** Enumeration representing distance units options. */
export declare enum GeoUnit {
    /** Represents distance in meters. */
    METERS = "m",
    /** Represents distance in kilometers. */
    KILOMETERS = "km",
    /** Represents distance in miles. */
    MILES = "mi",
    /** Represents distance in feet. */
    FEET = "ft"
}
/**
 * Optional parameters for {@link BaseClient.geosearch|geosearch} command which defines what should be included in the
 * search results and how results should be ordered and limited.
 */
export type GeoSearchResultOptions = GeoSearchCommonResultOptions & {
    /** Include the coordinate of the returned items. */
    withCoord?: boolean;
    /**
     * Include the distance of the returned items from the specified center point.
     * The distance is returned in the same unit as specified for the `searchBy` argument.
     */
    withDist?: boolean;
    /** Include the geohash of the returned items. */
    withHash?: boolean;
};
/**
 * Optional parameters for {@link BaseClient.geosearchstore|geosearchstore} command which defines what should be included in the
 * search results and how results should be ordered and limited.
 */
export type GeoSearchStoreResultOptions = GeoSearchCommonResultOptions & {
    /**
     * Determines what is stored as the sorted set score. Defaults to `false`.
     * - If set to `false`, the geohash of the location will be stored as the sorted set score.
     * - If set to `true`, the distance from the center of the shape (circle or box) will be stored as the sorted set score. The distance is represented as a floating-point number in the same unit specified for that shape.
     */
    storeDist?: boolean;
};
interface GeoSearchCommonResultOptions {
    /** Indicates the order the result should be sorted in. */
    sortOrder?: SortOrder;
    /** Indicates the number of matches the result should be limited to. */
    count?: number;
    /** Whether to allow returning as enough matches are found. This requires `count` parameter to be set. */
    isAny?: boolean;
}
/** Defines the sort order for nested results. */
export declare enum SortOrder {
    /** Sort by ascending order. */
    ASC = "ASC",
    /** Sort by descending order. */
    DESC = "DESC"
}
export type GeoSearchShape = GeoCircleShape | GeoBoxShape;
/** Circle search shape defined by the radius value and measurement unit. */
export interface GeoCircleShape {
    /** The radius to search by. */
    radius: number;
    /** The measurement unit of the radius. */
    unit: GeoUnit;
}
/** Rectangle search shape defined by the width and height and measurement unit. */
export interface GeoBoxShape {
    /** The width of the rectangle to search by. */
    width: number;
    /** The height of the rectangle to search by. */
    height: number;
    /** The measurement unit of the width and height. */
    unit: GeoUnit;
}
export type SearchOrigin = CoordOrigin | MemberOrigin;
/** The search origin represented by a {@link GeospatialData} position. */
export interface CoordOrigin {
    /** The pivot location to search from. */
    position: GeospatialData;
}
/** The search origin represented by an existing member. */
export interface MemberOrigin {
    /** Member (location) name stored in the sorted set to use as a search pivot. */
    member: GlideString;
}
/**
 * Mandatory option for zmpop.
 * Defines which elements to pop from the sorted set.
 */
export declare enum ScoreFilter {
    /** Pop elements with the highest scores. */
    MAX = "MAX",
    /** Pop elements with the lowest scores. */
    MIN = "MIN"
}
/**
 * Optional arguments to {@link BaseClient.sort|sort}, {@link BaseClient.sortStore|sortStore} and {@link BaseClient.sortReadOnly|sortReadOnly} commands.
 *
 * See https://valkey.io/commands/sort/ for more details.
 *
 * @remarks When in cluster mode, {@link SortOptions.byPattern|byPattern} and {@link SortOptions.getPatterns|getPattern} must map to the same hash
 *     slot as the key, and this is supported only since Valkey version 8.0.
 */
export interface SortOptions {
    /**
     * A pattern to sort by external keys instead of by the elements stored at the key themselves. The
     * pattern should contain an asterisk (*) as a placeholder for the element values, where the value
     * from the key replaces the asterisk to create the key name. For example, if `key`
     * contains IDs of objects, `byPattern` can be used to sort these IDs based on an
     * attribute of the objects, like their weights or timestamps.
     * Supported in cluster mode since Valkey version 8.0 and above.
     */
    byPattern?: GlideString;
    /**
     * Limiting the range of the query by setting offset and result count. See {@link Limit} class for
     * more information.
     */
    limit?: Limit;
    /**
     * A pattern used to retrieve external keys' values, instead of the elements at `key`.
     * The pattern should contain an asterisk (`*`) as a placeholder for the element values, where the
     * value from `key` replaces the asterisk to create the `key` name. This
     * allows the sorted elements to be transformed based on the related keys values. For example, if
     * `key` contains IDs of users, `getPatterns` can be used to retrieve
     * specific attributes of these users, such as their names or email addresses. E.g., if
     * `getPatterns` is `name_*`, the command will return the values of the keys
     * `name_<element>` for each sorted element. Multiple `getPatterns`
     * arguments can be provided to retrieve multiple attributes. The special value `#` can
     * be used to include the actual element from `key` being sorted. If not provided, only
     * the sorted elements themselves are returned.
     * Supported in cluster mode since Valkey version 8.0 and above.
     */
    getPatterns?: GlideString[];
    /** Options for sorting order of elements. */
    orderBy?: SortOrder;
    /**
     * When `true`, sorts elements lexicographically. When `false` (default),
     * sorts elements numerically. Use this when the list, set, or sorted set contains string values
     * that cannot be converted into double precision floating point numbers.
     */
    isAlpha?: boolean;
}
/**
 * The `LIMIT` argument is commonly used to specify a subset of results from the
 * matching elements, similar to the `LIMIT` clause in SQL (e.g., `SELECT LIMIT offset, count`).
 */
export interface Limit {
    /** The starting position of the range, zero based. */
    offset: number;
    /** The maximum number of elements to include in the range. A negative count returns all elements from the offset. */
    count: number;
}
/**
 * This base class represents the common set of optional arguments for the SCAN family of commands.
 * Concrete implementations of this class are tied to specific SCAN commands (`SCAN`, `SSCAN`).
 */
export interface BaseScanOptions {
    /**
     * The match filter is applied to the result of the command and will only include
     * strings that match the pattern specified. If the sorted set is large enough for scan commands to return
     * only a subset of the sorted set then there could be a case where the result is empty although there are
     * items that match the pattern specified. This is due to the default `COUNT` being `10` which indicates
     * that it will only fetch and match `10` items from the list.
     */
    match?: GlideString;
    /**
     * `COUNT` is a just a hint for the command for how many elements to fetch from the
     * sorted set. `COUNT` could be ignored until the sorted set is large enough for the `SCAN` commands to
     * represent the results as compact single-allocation packed encoding.
     */
    readonly count?: number;
}
/**
 * Options for the SCAN command.
 * `match`: The match filter is applied to the result of the command and will only include keys that match the pattern specified.
 * `count`: `COUNT` is a just a hint for the command for how many elements to fetch from the server, the default is 10.
 * `type`: The type of the object to scan.
 *  Types are the data types of Valkey: `string`, `list`, `set`, `zset`, `hash`, `stream`.
 */
export interface ScanOptions extends BaseScanOptions {
    type?: ObjectType;
}
/**
 * Options for the SCAN command.
 * `match`: The match filter is applied to the result of the command and will only include keys that match the pattern specified.
 * `count`: `COUNT` is a just a hint for the command for how many elements to fetch from the server, the default is 10.
 * `type`: The type of the object to scan.
 * Types are the data types of Valkey: `string`, `list`, `set`, `zset`, `hash`, `stream`.
 * `allowNonCoveredSlots`: If true, the scan will keep scanning even if slots are not covered by the cluster.
 * By default, the scan will stop if slots are not covered by the cluster.
 */
export interface ClusterScanOptions extends ScanOptions {
    allowNonCoveredSlots?: boolean;
}
/**
 * Options specific to the ZSCAN command, extending from the base scan options.
 */
export type ZScanOptions = BaseScanOptions & {
    /**
     * If true, the scores are not included in the results.
     * Supported from Valkey 8.0.0 and above.
     */
    readonly noScores?: boolean;
};
/**
 * Options specific to the HSCAN command, extending from the base scan options.
 */
export type HScanOptions = BaseScanOptions & {
    /**
     * If true, the values of the fields are not included in the results.
     * Supported from Valkey 8.0.0 and above.
     */
    readonly noValues?: boolean;
};
/**
 * Time unit representation which is used in optional arguments for {@link BaseClient.getex|getex} and {@link BaseClient.set|set} command.
 */
export declare enum TimeUnit {
    /**
     * Set the specified expire time, in seconds. Equivalent to
     * `EX` in the VALKEY API.
     */
    Seconds = "EX",
    /**
     * Set the specified expire time, in milliseconds. Equivalent
     * to `PX` in the VALKEY API.
     */
    Milliseconds = "PX",
    /**
     * Set the specified Unix time at which the key will expire,
     * in seconds. Equivalent to `EXAT` in the VALKEY API.
     */
    UnixSeconds = "EXAT",
    /**
     * Set the specified Unix time at which the key will expire,
     * in milliseconds. Equivalent to `PXAT` in the VALKEY API.
     */
    UnixMilliseconds = "PXAT"
}
/**
 * Base options settings class for sending a batch request. Shared settings for standalone and
 * cluster batch requests.
 *
 * ### Timeout
 * The duration in milliseconds that the client should wait for the batch request to complete.
 * This duration encompasses sending the request, awaiting a response from the server, and any
 * required reconnections or retries. If the specified timeout is exceeded for a pending request,
 * it will result in a timeout error. If not explicitly set, the client's {@link BaseClientConfiguration.requestTimeout | requestTimeout} will be used.
 *
 * @example
 * ```javascript
 * const options: BaseBatchOptions = {
 *   timeout: 5000, // 5 seconds
 * };
 * ```
 */
export interface BaseBatchOptions {
    /**
     * The duration in milliseconds that the client should wait for the batch request to complete.
     * This duration encompasses sending the request, awaiting a response from the server, and any
     * required reconnections or retries. If the specified timeout is exceeded for a pending request,
     * it will result in a timeout error. If not explicitly set, the client's {@link BaseClientConfiguration.requestTimeout | requestTimeout} will be used.
     */
    timeout?: number;
}
/** Options for a batch request for a standalone client.
 *
 * @example
 * ```javascript
 * const options: BatchOptions = {
 *   timeout: 5000, // 5 seconds
 * };
 * ```
 */
export type BatchOptions = {} & BaseBatchOptions;
/**
 * Options for a batch request for a cluster client.
 *
 * ### Route
 * Configures single-node routing for the batch request. The client will send the batch to the
 * specified node defined by <code>route</code>.
 *
 * ### Retry Strategy
 * ⚠️ **Please read {@link ClusterBatchRetryStrategy} carefully before enabling these configurations.**
 * Defines the retry strategy for handling batch request failures.
 *
 * This strategy determines whether failed commands should be retried, potentially impacting
 * execution order.
 *
 * - If `retryServerError` is `true`, retriable errors (e.g., `TRYAGAIN`) will trigger a retry.
 * - If `retryConnectionError` is `true`, connection failures will trigger a retry.
 *
 * **⚠️ Warnings:**
 *
 * - Retrying server errors may cause commands targeting the same slot to execute out of order.
 * - Retrying connection errors may lead to duplicate executions, as it is unclear which
 *   commands have already been processed.
 *
 * **Note:** Currently, retry strategies are supported only for non-atomic batches.
 *
 * **Recommendation:** It is recommended to increase the timeout in {@link BaseBatchOptions.timeout | BaseBatchOptions}
 * when enabling these strategies.
 *
 * **Default:** Both `retryServerError` and `retryConnectionError` are set to `false`.
 *
 * @example
 * ```javascript
 * const options: ClusterBatchOptions = {
 *   timeout: 5000, // 5 seconds
 *   route: "randomNode",
 *   retryStrategy: {
 *     retryServerError: false,
 *     retryConnectionError: false,
 *   },
 * };
 * ```
 */
export type ClusterBatchOptions = {
    /**
     * Configures single-node routing for the batch request. The client will send the batch to the
     * specified node defined by `route`.
     *
     * If a redirection error occurs:
     *
     * - For Atomic Batches (Transactions), the entire transaction will be redirected.
     * - For Non-Atomic Batches (Pipelines), only the commands that encountered redirection errors
     *   will be redirected.
     */
    route?: SingleNodeRoute;
    /**
     * ⚠️ **Please see {@link ClusterBatchRetryStrategy} and read carefully before enabling these configurations.**
     *
     * Defines the retry strategy for handling batch request failures.
     *
     * This strategy determines whether failed commands should be retried, potentially impacting
     * execution order.
     *
     * - If `retryServerError` is `true`, retriable errors (e.g., `TRYAGAIN`) will trigger a retry.
     * - If `retryConnectionError` is `true`, connection failures will trigger a retry.
     *
     * **⚠️ Warnings:**
     *
     * - Retrying server errors may cause commands targeting the same slot to execute out of order.
     * - Retrying connection errors may lead to duplicate executions, as it is unclear which
     *   commands have already been processed.
     *
     * **Note:** Currently, retry strategies are supported only for non-atomic batches.
     *
     * **Recommendation:** It is recommended to increase the timeout in {@link BaseBatchOptions.timeout | BaseBatchOptions}
     * when enabling these strategies.
     *
     * **Default:** Both `retryServerError` and `retryConnectionError` are set to `false`.
     */
    retryStrategy?: ClusterBatchRetryStrategy;
} & BaseBatchOptions;
/**
 * Defines a retry strategy for batch requests, allowing control over retries in case of server or
 * connection errors.
 *
 * This strategy determines whether failed commands should be retried, impacting execution order
 * and potential side effects.
 *
 * ### Behavior
 *
 * - If `retryServerError` is `true`, failed commands with a retriable error (e.g., `TRYAGAIN`) will be retried.
 * - If `retryConnectionError` is `true`, batch requests will be retried on connection failures.
 *
 * ### Cautions
 *
 * - **Server Errors:** Retrying may cause commands targeting the same slot to be executed out of order.
 * - **Connection Errors:** Retrying may lead to duplicate executions, since the server might have already received and processed the request before the error occurred.
 *
 * ### Example Scenario
 *
 * ```
 * MGET key {key}:1
 * SET key "value"
 * ```
 *
 * Expected response when keys are empty:
 *
 * ```
 * [null, null]
 * OK
 * ```
 *
 * However, if the slot is migrating, both commands may return an `ASK` error and be redirected.
 * Upon `ASK` redirection, a multi-key command may return a `TRYAGAIN` error (triggering a retry), while
 * the `SET` command succeeds immediately. This can result in an unintended reordering of commands if
 * the first command is retried after the slot stabilizes:
 *
 * ```
 * ["value", null]
 * OK
 * ```
 *
 * **Note:** Currently, retry strategies are supported only for non-atomic batches.
 */
export interface ClusterBatchRetryStrategy {
    /**
     * If `true`, failed commands with a retriable error (e.g., `TRYAGAIN`) will be automatically retried.
     *
     * ⚠️ **Warning:** Enabling this flag may cause commands targeting the same slot to execute out of order.
     */
    retryServerError: boolean;
    /**
     * If `true`, batch requests will be retried in case of connection errors.
     *
     * ⚠️ **Warning:** Retrying after a connection error may lead to duplicate executions, since
     * the server might have already received and processed the request before the error occurred.
     */
    retryConnectionError: boolean;
}
export {};
